"""
Dynamic Copy Trading Script
This script loads account configurations dynamically from the config file
generated by the EC2 account server.
"""

import MetaTrader5 as mt5
import subprocess
import time
import multiprocessing
import sys
import os
import configparser
import winreg
import requests
import json
import psycopg2
from datetime import datetime

# Default paths and settings (non-account specific)
DEFAULT_CONFIG = {
    "MASTER_PATH": r"C:\Users\Administrator\Desktop\terminals\master\terminal64.exe",
    "SLAVE_PATH": r"C:\Users\Administrator\Desktop\terminals\slave1\terminal64.exe",
    "COPY_INTERVAL": 1,
    "DISCORD_WEBHOOK_URL": "https://discord.com/api/webhooks/1405657359438712903/3SR_iC1jWXOckZKRLv73Gg_l0_3v02v1vEZVwOclXfupq-jN2pUt3GFqLYzTNJZUjFCx"
}

def load_configuration_from_database(user_id):
    """Load configuration directly from the database"""
    config = DEFAULT_CONFIG.copy()
    
    try:
        # Database connection parameters - you'll need to set these
        # You can pass these as environment variables to the EC2
        # Get database credentials from environment variables only
        db_host = os.environ.get('DB_HOST')
        db_name = os.environ.get('DB_NAME')
        db_user = os.environ.get('DB_USER')
        db_password = os.environ.get('DB_PASSWORD')
        db_port = os.environ.get('DB_PORT')
        
        # Validate all required environment variables are set
        if not all([db_host, db_name, db_user, db_password, db_port]):
            missing = []
            if not db_host: missing.append('DB_HOST')
            if not db_name: missing.append('DB_NAME')
            if not db_user: missing.append('DB_USER')
            if not db_password: missing.append('DB_PASSWORD')
            if not db_port: missing.append('DB_PORT')
            
            print(f"‚ùå Missing required database environment variables: {', '.join(missing)}")
            print("Please set all database environment variables before running the script.")
            return None
        
        # Debug: Print connection details (without password)
        print(f"üîó Connecting to database:")
        print(f"   Host: {db_host}")
        print(f"   Database: {db_name}")
        print(f"   User: {db_user}")
        print(f"   Port: {db_port}")
        
        conn = psycopg2.connect(
            host=db_host,
            database=db_name,
            user=db_user,
            password=db_password,
            port=int(db_port)
        )
        
        cursor = conn.cursor()
        
        # Get user's active accounts
        cursor.execute("""
            SELECT account_login, account_password, server, account_is_master 
            FROM accounts 
            WHERE user_id = %s AND is_active = true
            ORDER BY account_is_master DESC
        """, (user_id,))
        
        accounts = cursor.fetchall()
        
        if not accounts:
            print(f"‚ùå No active accounts found for user {user_id}")
            return None
        
        # Separate master and slave accounts
        master_account = None
        slave_accounts = []
        
        for login, password, server, is_master in accounts:
            if is_master:
                master_account = (login, password, server)
            else:
                slave_accounts.append((login, password, server))
        
        if not master_account:
            print(f"‚ùå No master account found for user {user_id}")
            return None
            
        if not slave_accounts:
            print(f"‚ùå No slave accounts found for user {user_id}")
            return None
        
        # Set master account
        config['MASTER_LOGIN'] = master_account[0]
        config['MASTER_PASSWORD'] = master_account[1]
        config['MASTER_SERVER'] = master_account[2]
        
        # Set first slave account (you can extend this for multiple slaves later)
        config['SLAVE_LOGIN'] = slave_accounts[0][0]
        config['SLAVE_PASSWORD'] = slave_accounts[0][1]
        config['SLAVE_SERVER'] = slave_accounts[0][2]
        
        # Store all slave accounts for future use
        config['ALL_SLAVE_ACCOUNTS'] = slave_accounts
        
        print(f"‚úÖ Loaded from database - User: {user_id}")
        print(f"üéØ Master: {config['MASTER_LOGIN']}")
        print(f"üéØ Slaves: {len(slave_accounts)}")
        
        cursor.close()
        conn.close()
        
        return config
        
    except Exception as e:
        print(f"‚ùå Error loading configuration from database: {e}")
        return None

def get_user_id_from_ec2():
    """Get the user ID from EC2 instance metadata or environment variable"""
    try:
        # Try to get from environment variable first
        print("üîç Looking for TRADING_USER_ID environment variable...")
        user_id = os.environ.get('TRADING_USER_ID')
        if user_id:
            print(f"‚úÖ Found user ID in environment: {user_id}")
            return int(user_id)
        
        print("‚ö†Ô∏è TRADING_USER_ID not found in environment, trying EC2 tags...")
        
        # Try to get from EC2 instance tags
        import boto3
        ec2 = boto3.client('ec2', region_name=os.environ.get('AWS_REGION', 'us-east-1'))
        
        # Get instance ID
        response = requests.get('http://169.254.169.254/latest/meta-data/instance-id', timeout=5)
        instance_id = response.text
        print(f"üìã Instance ID: {instance_id}")
        
        # Get instance tags
        response = ec2.describe_instances(InstanceIds=[instance_id])
        tags = response['Reservations'][0]['Instances'][0].get('Tags', [])
        
        print(f"üè∑Ô∏è Instance tags: {tags}")
        
        for tag in tags:
            if tag['Key'] == 'User':
                print(f"‚úÖ Found user ID in EC2 tags: {tag['Value']}")
                return int(tag['Value'])
        
        print("‚ùå No user ID found in environment or EC2 tags")
        return None
        
    except Exception as e:
        print(f"‚ùå Error getting user ID: {e}")
        return None

def send_discord_notification(message, webhook_url):
    """Send notification to Discord"""
    try:
        payload = {
            "content": message,
            "username": "MT5 Copy Trading Bot"
        }
        
        response = requests.post(webhook_url, json=payload)
        if response.status_code == 204:
            print(f"‚úÖ Discord notification sent: {message}")
        else:
            print(f"‚ùå Failed to send Discord notification: {response.status_code}")
    except Exception as e:
        print(f"‚ùå Failed to send Discord notification: {e}")

def enable_algo_trading_in_config(terminal_path):
    """Enable algorithmic trading by creating comprehensive config files"""
    try:
        # Get the terminal directory
        terminal_dir = os.path.dirname(terminal_path)
        config_dir = os.path.join(terminal_dir, "config")
        os.makedirs(config_dir, exist_ok=True)
        
        # 1. Create/update common.ini
        common_config_path = os.path.join(config_dir, "common.ini")
        common_config_content = """[Terminal]
AllowLiveTrading=1
AllowDllImport=1
AllowWebRequest=1
AllowAutoTrading=1
AllowExternalExperts=1
AllowExternalSignals=1
AllowExternalAlerts=1
AllowSendNotifications=1
AllowSendEmail=1
AllowSendSMS=1
AllowSendPush=1
AllowSendWebRequest=1
AllowSendFTP=1
AllowSendTerminal=1
AllowSendTerminalEmail=1
AllowSendTerminalSMS=1
AllowSendTerminalPush=1
AllowSendTerminalWebRequest=1
AllowSendTerminalFTP=1
AllowSendTerminalTerminal=1
"""
        
        with open(common_config_path, 'w', encoding='utf-8') as configfile:
            configfile.write(common_config_content)
        
        print(f"‚úÖ Created comprehensive common.ini: {common_config_path}")
        
        # 2. Create/update terminal.ini
        terminal_config_path = os.path.join(config_dir, "terminal.ini")
        terminal_config_content = """[Terminal]
AllowLiveTrading=1
AllowDllImport=1
AllowWebRequest=1
AllowAutoTrading=1
AllowExternalExperts=1
AllowExternalSignals=1
AllowExternalAlerts=1
AllowSendNotifications=1
AllowSendEmail=1
AllowSendSMS=1
AllowSendPush=1
AllowSendWebRequest=1
AllowSendFTP=1
AllowSendTerminal=1
AllowSendTerminalEmail=1
AllowSendTerminalSMS=1
AllowSendTerminalPush=1
AllowSendTerminalWebRequest=1
AllowSendTerminalFTP=1
AllowSendTerminalTerminal=1
"""
        
        with open(terminal_config_path, 'w', encoding='utf-8') as configfile:
            configfile.write(terminal_config_content)
        
        print(f"‚úÖ Created terminal.ini: {terminal_config_path}")
        
        # 3. Create/update experts.ini
        experts_config_path = os.path.join(config_dir, "experts.ini")
        experts_config_content = """[Experts]
AllowLiveTrading=1
AllowDllImport=1
AllowWebRequest=1
AllowAutoTrading=1
AllowExternalExperts=1
AllowExternalSignals=1
AllowExternalAlerts=1
AllowSendNotifications=1
AllowSendEmail=1
AllowSendSMS=1
AllowSendPush=1
AllowSendWebRequest=1
AllowSendFTP=1
AllowSendTerminal=1
AllowSendTerminalEmail=1
AllowSendTerminalSMS=1
AllowSendTerminalPush=1
AllowSendTerminalWebRequest=1
AllowSendTerminalFTP=1
AllowSendTerminalTerminal=1
"""
        
        with open(experts_config_path, 'w', encoding='utf-8') as configfile:
            configfile.write(experts_config_content)
        
        print(f"‚úÖ Created experts.ini: {experts_config_path}")
        
        # 4. Create/update profiles.ini
        profiles_config_path = os.path.join(config_dir, "profiles.ini")
        profiles_config_content = """[Profiles]
Default=Default
"""
        
        with open(profiles_config_path, 'w', encoding='utf-8') as configfile:
            configfile.write(profiles_config_content)
        
        print(f"‚úÖ Created profiles.ini: {profiles_config_path}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Failed to create config files: {e}")
        return False

def enable_algo_trading_via_registry(terminal_path):
    """Enable algorithmic trading via Windows registry"""
    try:
        terminal_dir = os.path.dirname(terminal_path)
        registry_keys = [
            f"SOFTWARE\\MetaQuotes\\Terminal\\{terminal_dir.replace(':', '').replace('\\', '_')}",
            "SOFTWARE\\MetaQuotes\\Terminal",
            "SOFTWARE\\MetaQuotes\\Terminal\\Common",
            f"SOFTWARE\\MetaQuotes\\Terminal\\{os.path.basename(terminal_dir)}"
        ]
        
        for registry_key in registry_keys:
            try:
                with winreg.CreateKey(winreg.HKEY_CURRENT_USER, registry_key) as key:
                    winreg.SetValueEx(key, "AllowLiveTrading", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowDllImport", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowWebRequest", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowAutoTrading", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowExternalExperts", 0, winreg.REG_DWORD, 1)
                
                print(f"‚úÖ Algorithmic trading enabled in registry: {registry_key}")
                return True
                
            except Exception as e:
                continue
        
        print(f"‚ö†Ô∏è  Could not enable via registry for any key")
        return False
        
    except Exception as e:
        print(f"‚ö†Ô∏è  Could not enable via registry: {e}")
        return False

def save_login_credentials(terminal_path, login, password, server):
    """Save login credentials in MT5 terminal"""
    try:
        terminal_dir = os.path.dirname(terminal_path)
        config_dir = os.path.join(terminal_dir, "config")
        os.makedirs(config_dir, exist_ok=True)
        
        accounts_path = os.path.join(config_dir, "accounts.ini")
        
        config = configparser.ConfigParser()
        if os.path.exists(accounts_path):
            config.read(accounts_path, encoding='utf-8')
        
        account_section = f"Account{login}"
        if account_section not in config:
            config[account_section] = {}
        
        config[account_section]['Login'] = str(login)
        config[account_section]['Password'] = password
        config[account_section]['Server'] = server
        config[account_section]['SavePassword'] = '1'
        config[account_section]['AutoLogin'] = '1'
        
        with open(accounts_path, 'w', encoding='utf-8') as configfile:
            config.write(configfile)
        
        print(f"‚úÖ Saved login credentials for account {login}")
        return True
        
    except Exception as e:
        print(f"‚ùå Failed to save login credentials: {e}")
        return False

def start_mt5_terminal(path):
    """Start MT5 terminal in headless mode"""
    try:
        # Launch with portable mode and headless flags
        subprocess.Popen([path, "/portable", "/headless"])
        time.sleep(10)  # Give MT5 more time to start in headless mode
        print(f"‚úÖ Started MT5 terminal: {path}")
    except Exception as e:
        print(f"‚ùå Error starting MT5 terminal: {e}")

def wait_for_terminal_ready(terminal_path, login, password, server, max_attempts=30):
    """Wait for terminal to be ready and connected"""
    print(f"‚è≥ Waiting for terminal to be ready...")
    
    for attempt in range(max_attempts):
        try:
            if mt5.initialize(path=terminal_path, login=login, password=password, server=server):
                account_info = mt5.account_info()
                if account_info:
                    print(f"‚úÖ Terminal ready! Account: {account_info.login}")
                    mt5.shutdown()
                    return True
                else:
                    print(f"‚ö†Ô∏è  Terminal connected but no account info (attempt {attempt + 1})")
                    mt5.shutdown()
            else:
                print(f"‚ö†Ô∏è  Terminal not ready yet (attempt {attempt + 1})")
        except Exception as e:
            print(f"‚ö†Ô∏è  Connection attempt {attempt + 1} failed: {e}")
            mt5.shutdown()
        
        time.sleep(5)
    
    print(f"‚ùå Terminal not ready after {max_attempts} attempts")
    return False

def force_enable_autotrading_via_api(terminal_path, login, password, server):
    """Try to force enable AutoTrading via MT5 API"""
    try:
        if mt5.initialize(path=terminal_path, login=login, password=password, server=server):
            # Try to get terminal info and check if we can modify settings
            terminal_info = mt5.terminal_info()
            print(f"Terminal info - Trade allowed: {terminal_info.trade_allowed}")
            print(f"Terminal info - Trade mode: {terminal_info.trade_mode}")
            print(f"Terminal info - Connected: {terminal_info.connected}")
            print(f"Terminal info - Trade allowed: {terminal_info.trade_allowed}")
            
            # Try to get account info
            account_info = mt5.account_info()
            if account_info:
                print(f"Account info - Trade allowed: {account_info.trade_allowed}")
                print(f"Account info - Trade mode: {account_info.trade_mode}")
                print(f"Account info - Trade expert: {account_info.trade_expert}")
            
            mt5.shutdown()
            return True
        else:
            print(f"‚ùå Could not initialize MT5 for API access")
            mt5.shutdown()
            return False
    except Exception as e:
        print(f"‚ö†Ô∏è  Could not force enable via API: {e}")
        mt5.shutdown()
        return False

def check_autotrading_status(terminal_path, login, password, server):
    """Check if AutoTrading is currently enabled"""
    try:
        if mt5.initialize(path=terminal_path, login=login, password=password, server=server):
            terminal_info = mt5.terminal_info()
            mt5.shutdown()
            return terminal_info.trade_allowed
        else:
            mt5.shutdown()
            return False
    except Exception as e:
        print(f"‚ö†Ô∏è  Could not check AutoTrading status: {e}")
        mt5.shutdown()
        return False

def setup_single_terminal(terminal_path, login, password, server, terminal_name):
    """Setup a single terminal: launch, wait for connection, verify AutoTrading"""
    try:
        print(f"\n{'='*60}")
        print(f"üöÄ Setting up {terminal_name} terminal...")
        print(f"{'='*60}")
        
        # Step 1: Save credentials and launch terminal
        print(f"üìã Step 1: Saving credentials for {terminal_name}...")
        save_login_credentials(terminal_path, login, password, server)
        
        print(f"üöÄ Step 2: Launching {terminal_name} terminal...")
        start_mt5_terminal(terminal_path)
        
        # Step 3: Wait for terminal to be ready
        print(f"‚è≥ Step 3: Waiting for {terminal_name} terminal to be ready...")
        if not wait_for_terminal_ready(terminal_path, login, password, server):
            print(f"‚ùå {terminal_name} terminal not ready")
            return False
        
        # Step 4: Try to force enable AutoTrading via API
        print(f"üîß Step 4: Attempting to force enable AutoTrading for {terminal_name}...")
        force_enable_autotrading_via_api(terminal_path, login, password, server)
        
        # Step 5: Verify AutoTrading is enabled
        print(f"‚úÖ Step 5: Verifying AutoTrading for {terminal_name}...")
        autotrading_enabled = False
        for attempt in range(10):  # Increased attempts
            try:
                if check_autotrading_status(terminal_path, login, password, server):
                    print(f"‚úÖ CONFIRMED: AutoTrading is ENABLED for {terminal_name}")
                    autotrading_enabled = True
                    break
                else:
                    print(f"‚ùå AutoTrading is DISABLED for {terminal_name} (attempt {attempt + 1})")
                    
                    # Try to restart terminal if AutoTrading is still disabled after several attempts
                    if attempt == 5:
                        print(f"üîÑ Attempting to restart {terminal_name} terminal to enable AutoTrading...")
                        # Kill existing process
                        try:
                            subprocess.run(['taskkill', '/f', '/im', 'terminal64.exe'], 
                                         capture_output=True, check=False)
                            time.sleep(5)
                        except:
                            pass
                        
                        # Restart with different flags
                        try:
                            subprocess.Popen([terminal_path, "/portable", "/headless", "/autotrading"])
                            time.sleep(15)
                        except:
                            pass
                    
            except Exception as e:
                print(f"‚ö†Ô∏è  AutoTrading verification attempt {attempt + 1} failed: {e}")
            
            if attempt < 9:  # Don't sleep after last attempt
                time.sleep(3)
        
        if not autotrading_enabled:
            print(f"‚ö†Ô∏è  AutoTrading could not be enabled for {terminal_name}, but continuing anyway...")
            # Don't exit, just continue with the setup
            return True
        
        return autotrading_enabled
        
    except Exception as e:
        print(f"‚ùå Error setting up {terminal_name} terminal: {e}")
        return False

def init_account(login, password, server, terminal_path):
    """Initialize MT5 account connection"""
    if not mt5.initialize(path=terminal_path, login=login, password=password, server=server):
        print(f"‚ùå Failed to initialize MT5 account {login}: {mt5.last_error()}")
        return False
    
    account_info = mt5.account_info()
    if account_info:
        print(f"‚úÖ Account {login} logged in successfully")
        return True
    else:
        print(f"‚ùå Account {login} connected but no account info")
        mt5.shutdown()
        return False

def get_master_positions():
    """Get all open positions from master account"""
    return mt5.positions_get()

def get_safe_tick_price(symbol, order_type):
    """Get tick price with fallback to symbol info if tick is not available"""
    tick = mt5.symbol_info_tick(symbol)
    if tick is None:
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info is None:
            print(f"‚ùå Cannot get price info for {symbol}")
            return None
        
        if order_type == 0:  # BUY
            return symbol_info.ask
        else:  # SELL
            return symbol_info.bid
    else:
        if order_type == 0:  # BUY
            return tick.ask
        else:  # SELL
            return tick.bid

def copy_position_to_slave(position):
    """Copy a position from master to slave account"""
    symbol = position.symbol
    volume = position.volume
    order_type = position.type
    
    price = get_safe_tick_price(symbol, order_type)
    if price is None:
        print(f"‚ùå Cannot get price for {symbol}, skipping trade")
        return False

    request = { 
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": volume,
        "type": order_type,
        "price": price,
        "deviation": 10,
        "magic": 123456,
        "comment": "Trade copied",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_FOK,
    }

    result = mt5.order_send(request)
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"‚ùå Trade failed: retcode={result.retcode}, message: {result.comment}")
        return False
    else:
        print(f"‚úÖ Trade copied: {symbol}, {volume} lots, {'BUY' if order_type == 0 else 'SELL'}")
        return True

def positions_to_dict(positions):
    """Convert positions to a dictionary for comparison"""
    if positions is None:
        return {}
    return {(p.symbol, p.volume, p.type): p.ticket for p in positions}

def copy_trading_process(config):
    """Main copy trading process that runs continuously"""
    print("üéØ Starting copy trading process...")
    
    MASTER_LOGIN = config['MASTER_LOGIN']
    MASTER_PASSWORD = config['MASTER_PASSWORD']
    MASTER_SERVER = config['MASTER_SERVER']
    MASTER_PATH = config['MASTER_PATH']
    
    SLAVE_LOGIN = config['SLAVE_LOGIN']
    SLAVE_PASSWORD = config['SLAVE_PASSWORD']
    SLAVE_SERVER = config['SLAVE_SERVER']
    SLAVE_PATH = config['SLAVE_PATH']
    
    COPY_INTERVAL = config['COPY_INTERVAL']
    DISCORD_WEBHOOK_URL = config['DISCORD_WEBHOOK_URL']
    
    # Initialize baseline state - track existing positions when script starts
    baseline_master_positions = {}
    baseline_initialized = False
    
    while True:
        try:
            # Connect to master terminal
            if init_account(MASTER_LOGIN, MASTER_PASSWORD, MASTER_SERVER, MASTER_PATH):
                print("‚úÖ Connected to master")
                master_positions = get_master_positions()
                master_snapshot = positions_to_dict(master_positions)
                mt5.shutdown()
            else:
                print("‚ùå Failed to connect to master, retrying...")
                time.sleep(COPY_INTERVAL)
                continue

            # Connect to slave terminal
            if init_account(SLAVE_LOGIN, SLAVE_PASSWORD, SLAVE_SERVER, SLAVE_PATH):
                print("‚úÖ Connected to slave")
                slave_positions = get_master_positions()
                slave_snapshot = positions_to_dict(slave_positions)

                # Initialize baseline on first successful connection
                if not baseline_initialized:
                    print("üìä Initializing baseline - recording existing positions...")
                    baseline_master_positions = master_snapshot.copy()
                    baseline_initialized = True
                    print(f"üìä Baseline initialized with {len(baseline_master_positions)} existing positions")
                    
                    # Show existing positions for reference
                    if baseline_master_positions:
                        print("üìã Existing positions (will NOT be copied):")
                        for pos_key in baseline_master_positions.keys():
                            symbol, volume, order_type = pos_key
                            print(f"   - {symbol}: {volume} lots ({'BUY' if order_type == 0 else 'SELL'})")
                    else:
                        print("üìã No existing positions found")
                    
                    # Send Discord notification about baseline initialization
                    send_discord_notification(
                        f"üìä Copy trading baseline initialized - {len(baseline_master_positions)} existing positions recorded",
                        DISCORD_WEBHOOK_URL
                    )
                    
                    # Continue to next iteration without copying anything
                    mt5.shutdown()
                    time.sleep(COPY_INTERVAL)
                    continue

                # Find truly new positions (positions in master that weren't in baseline)
                new_positions = {}
                for pos_key, master_ticket in master_snapshot.items():
                    if pos_key not in baseline_master_positions:
                        new_positions[pos_key] = master_ticket

                if new_positions:
                    print(f"üéØ Found {len(new_positions)} new positions to copy")
                    # Copy only the new positions
                    for p in master_positions:
                        pos_key = (p.symbol, p.volume, p.type)
                        if pos_key in new_positions:
                            print(f"üìà Copying new position: {p.symbol} {p.volume} lots ({'BUY' if p.type == 0 else 'SELL'})")
                            if copy_position_to_slave(p):
                                send_discord_notification(
                                    f"‚úÖ Trade copied: {p.symbol} {p.volume} lots ({'BUY' if p.type == 0 else 'SELL'})",
                                    DISCORD_WEBHOOK_URL
                                )
                else:
                    print("‚úÖ No new positions to copy")

                # Update baseline to include any new positions we just copied
                # This prevents re-copying the same position if the script restarts
                baseline_master_positions.update(new_positions)
                
                mt5.shutdown()
            else:
                print("‚ùå Failed to connect to slave, retrying...")
                time.sleep(COPY_INTERVAL)
                continue

        except Exception as e:
            print(f"‚ùå Error in copy trading process: {e}")
            mt5.shutdown()
        
        time.sleep(COPY_INTERVAL)

if __name__ == "__main__":
    print("üöÄ Starting Dynamic MT5 Copy Trading...")
    
    # Get user ID from EC2 metadata or environment
    user_id = get_user_id_from_ec2()
    if user_id is None:
        print("‚ùå Could not determine user ID. Exiting.")
        sys.exit(1)
    
    print(f"üë§ Trading for user ID: {user_id}")
    
    # Load configuration from database
    config = load_configuration_from_database(user_id)
    
    if config is None:
        print("‚ùå No valid account configuration found in database.")
        print("‚è≥ Waiting for accounts to be added in dashboard...")
        
        # Wait for configuration in a loop
        while True:
            time.sleep(30)  # Check every 30 seconds
            print("üîÑ Checking database for account configuration...")
            config = load_configuration_from_database(user_id)
            if config is not None:
                print("‚úÖ Account configuration found in database!")
                break
    
    print(f"\n{'='*60}")
    print("üìã Current Configuration:")
    print(f"Master Account: {config['MASTER_LOGIN']}")
    print(f"Slave Account: {config['SLAVE_LOGIN']}")
    print(f"Copy Interval: {config['COPY_INTERVAL']} seconds")
    print(f"{'='*60}")
    
    # Send Discord notification
    send_discord_notification(
        f"üöÄ Dynamic Copy Trading started - Master: {config['MASTER_LOGIN']}, Slave: {config['SLAVE_LOGIN']}",
        config['DISCORD_WEBHOOK_URL']
    )
    
    # Setup terminals
    print(f"\nüöÄ Setting up terminals...")
    
    master_success = setup_single_terminal(
        config['MASTER_PATH'], 
        config['MASTER_LOGIN'], 
        config['MASTER_PASSWORD'], 
        config['MASTER_SERVER'], 
        "Master"
    )
    
    slave_success = setup_single_terminal(
        config['SLAVE_PATH'], 
        config['SLAVE_LOGIN'], 
        config['SLAVE_PASSWORD'], 
        config['SLAVE_SERVER'], 
        "Slave"
    )
    
    if master_success and slave_success:
        print(f"\nüéØ Both terminals ready! Starting copy trading...")
        send_discord_notification(
            f"‚úÖ Dynamic Copy Trading ready - Both terminals active!",
            config['DISCORD_WEBHOOK_URL']
        )
        
        try:
            copy_trading_process(config)
        except KeyboardInterrupt:
            send_discord_notification("‚èπÔ∏è Dynamic Copy Trading stopped by user", config['DISCORD_WEBHOOK_URL'])
            print("\nCopy trading stopped by user")
            mt5.shutdown()
        except Exception as e:
            send_discord_notification(f"‚ùå Dynamic Copy Trading error: {str(e)}", config['DISCORD_WEBHOOK_URL'])
            print(f"Error: {e}")
            mt5.shutdown()
    else:
        print("‚ùå Failed to setup terminals")
        send_discord_notification("‚ùå Failed to setup MT5 terminals", config['DISCORD_WEBHOOK_URL'])
