"""
Dynamic Copy Trading Script
This script loads account configurations dynamically from the config file
generated by the EC2 account server.
"""

import MetaTrader5 as mt5
import subprocess
import time
import multiprocessing
import sys
import os
import configparser
import winreg
import requests
import json
import psycopg2
from datetime import datetime

# Try to import win32gui for window management (optional)
try:
    import win32gui
    import win32con
    import win32api
    WIN32_AVAILABLE = True
except ImportError:
    WIN32_AVAILABLE = False
    print("‚ö†Ô∏è  win32gui not available - cannot force login dialogs")

# Default paths and settings (non-account specific)
DEFAULT_CONFIG = {
    "MASTER_PATH": r"C:\Users\Administrator\Desktop\terminals\master\terminal64.exe",
    "SLAVE_PATH": r"C:\Users\Administrator\Desktop\terminals\slave1\terminal64.exe",
    "COPY_INTERVAL": 1,
    "DISCORD_WEBHOOK_URL": "https://discord.com/api/webhooks/1405657359438712903/3SR_iC1jWXOckZKRLv73Gg_l0_3v02v1vEZVwOclXfupq-jN2pUt3GFqLYzTNJZUjFCx"
}

def load_configuration_from_database(user_id):
    """Load configuration directly from the database"""
    config = DEFAULT_CONFIG.copy()
    
    try:
        # Database connection parameters - you'll need to set these
        # You can pass these as environment variables to the EC2
        # Get database credentials from environment variables only
        db_host = os.environ.get('DB_HOST')
        db_name = os.environ.get('DB_NAME')
        db_user = os.environ.get('DB_USER')
        db_password = os.environ.get('DB_PASSWORD')
        db_port = os.environ.get('DB_PORT')
        
        # Validate all required environment variables are set
        if not all([db_host, db_name, db_user, db_password, db_port]):
            missing = []
            if not db_host: missing.append('DB_HOST')
            if not db_name: missing.append('DB_NAME')
            if not db_user: missing.append('DB_USER')
            if not db_password: missing.append('DB_PASSWORD')
            if not db_port: missing.append('DB_PORT')
            
            print(f"‚ùå Missing required database environment variables: {', '.join(missing)}")
            print("Please set all database environment variables before running the script.")
            return None
        
        # Debug: Print connection details (without password)
        print(f"üîó Connecting to database:")
        print(f"   Host: {db_host}")
        print(f"   Database: {db_name}")
        print(f"   User: {db_user}")
        print(f"   Port: {db_port}")
        
        conn = psycopg2.connect(
            host=db_host,
            database=db_name,
            user=db_user,
            password=db_password,
            port=int(db_port)
        )
        
        cursor = conn.cursor()
        
        # Get user's active accounts
        cursor.execute("""
            SELECT account_login, account_password, server, account_is_master 
            FROM accounts 
            WHERE user_id = %s AND is_active = true
            ORDER BY account_is_master DESC
        """, (user_id,))
        
        accounts = cursor.fetchall()
        
        if not accounts:
            print(f"‚ùå No active accounts found for user {user_id}")
            return None
        
        # Separate master and slave accounts
        master_account = None
        slave_accounts = []
        
        for login, password, server, is_master in accounts:
            if is_master:
                master_account = (login, password, server)
            else:
                slave_accounts.append((login, password, server))
        
        if not master_account:
            print(f"‚ùå No master account found for user {user_id}")
            return None
            
        if not slave_accounts:
            print(f"‚ùå No slave accounts found for user {user_id}")
            return None
        
        # Set master account
        config['MASTER_LOGIN'] = master_account[0]
        config['MASTER_PASSWORD'] = master_account[1]
        config['MASTER_SERVER'] = master_account[2]
        
        # Set first slave account (you can extend this for multiple slaves later)
        config['SLAVE_LOGIN'] = slave_accounts[0][0]
        config['SLAVE_PASSWORD'] = slave_accounts[0][1]
        config['SLAVE_SERVER'] = slave_accounts[0][2]
        
        # Store all slave accounts for future use
        config['ALL_SLAVE_ACCOUNTS'] = slave_accounts
        
        print(f"‚úÖ Loaded from database - User: {user_id}")
        print(f"üéØ Master: {config['MASTER_LOGIN']} (type: {type(config['MASTER_LOGIN'])})")
        print(f"üéØ Slave: {config['SLAVE_LOGIN']} (type: {type(config['SLAVE_LOGIN'])})")
        print(f"üéØ Slaves: {len(slave_accounts)}")
        
        # Debug: Show raw database values
        print(f"üîç Database raw values:")
        print(f"   Master account: {master_account}")
        print(f"   Slave account: {slave_accounts[0]}")
        print(f"   Master login type: {type(master_account[0])}")
        print(f"   Slave login type: {type(slave_accounts[0][0])}")
        
        cursor.close()
        conn.close()
        
        return config
        
    except Exception as e:
        print(f"‚ùå Error loading configuration from database: {e}")
        return None

def get_user_id_from_ec2():
    """Get the user ID from EC2 instance metadata or environment variable"""
    try:
        # Try to get from environment variable first
        print("üîç Looking for TRADING_USER_ID environment variable...")
        user_id = os.environ.get('TRADING_USER_ID')
        if user_id:
            print(f"‚úÖ Found user ID in environment: {user_id}")
            return int(user_id)
        
        print("‚ö†Ô∏è TRADING_USER_ID not found in environment, trying EC2 tags...")
        
        # Try to get from EC2 instance tags
        import boto3
        ec2 = boto3.client('ec2', region_name=os.environ.get('AWS_REGION', 'us-east-1'))
        
        # Get instance ID
        response = requests.get('http://169.254.169.254/latest/meta-data/instance-id', timeout=5)
        instance_id = response.text
        print(f"üìã Instance ID: {instance_id}")
        
        # Get instance tags
        response = ec2.describe_instances(InstanceIds=[instance_id])
        tags = response['Reservations'][0]['Instances'][0].get('Tags', [])
        
        print(f"üè∑Ô∏è Instance tags: {tags}")
        
        for tag in tags:
            if tag['Key'] == 'User':
                print(f"‚úÖ Found user ID in EC2 tags: {tag['Value']}")
                return int(tag['Value'])
        
        print("‚ùå No user ID found in environment or EC2 tags")
        return None
        
    except Exception as e:
        print(f"‚ùå Error getting user ID: {e}")
        return None

def send_discord_notification(message, webhook_url):
    """Send notification to Discord"""
    try:
        payload = {
            "content": message,
            "username": "MT5 Copy Trading Bot"
        }
        
        response = requests.post(webhook_url, json=payload)
        if response.status_code == 204:
            print(f"‚úÖ Discord notification sent: {message}")
        else:
            print(f"‚ùå Failed to send Discord notification: {response.status_code}")
    except Exception as e:
        print(f"‚ùå Failed to send Discord notification: {e}")

def enable_algo_trading_in_config(terminal_path):
    """Enable algorithmic trading by creating comprehensive config files"""
    try:
        # Get the terminal directory
        terminal_dir = os.path.dirname(terminal_path)
        config_dir = os.path.join(terminal_dir, "config")
        os.makedirs(config_dir, exist_ok=True)
        
        # 1. Create/update common.ini
        common_config_path = os.path.join(config_dir, "common.ini")
        common_config_content = """[Terminal]
AllowLiveTrading=1
AllowDllImport=1
AllowWebRequest=1
AllowAutoTrading=1
AllowExternalExperts=1
AllowExternalSignals=1
AllowExternalAlerts=1
AllowSendNotifications=1
AllowSendEmail=1
AllowSendSMS=1
AllowSendPush=1
AllowSendWebRequest=1
AllowSendFTP=1
AllowSendTerminal=1
AllowSendTerminalEmail=1
AllowSendTerminalSMS=1
AllowSendTerminalPush=1
AllowSendTerminalWebRequest=1
AllowSendTerminalFTP=1
AllowSendTerminalTerminal=1
"""
        
        with open(common_config_path, 'w', encoding='utf-8') as configfile:
            configfile.write(common_config_content)
        
        print(f"‚úÖ Created comprehensive common.ini: {common_config_path}")
        
        # 2. Create/update terminal.ini
        terminal_config_path = os.path.join(config_dir, "terminal.ini")
        terminal_config_content = """[Terminal]
AllowLiveTrading=1
AllowDllImport=1
AllowWebRequest=1
AllowAutoTrading=1
AllowExternalExperts=1
AllowExternalSignals=1
AllowExternalAlerts=1
AllowSendNotifications=1
AllowSendEmail=1
AllowSendSMS=1
AllowSendPush=1
AllowSendWebRequest=1
AllowSendFTP=1
AllowSendTerminal=1
AllowSendTerminalEmail=1
AllowSendTerminalSMS=1
AllowSendTerminalPush=1
AllowSendTerminalWebRequest=1
AllowSendTerminalFTP=1
AllowSendTerminalTerminal=1
"""
        
        with open(terminal_config_path, 'w', encoding='utf-8') as configfile:
            configfile.write(terminal_config_content)
        
        print(f"‚úÖ Created terminal.ini: {terminal_config_path}")
        
        # 3. Create/update experts.ini
        experts_config_path = os.path.join(config_dir, "experts.ini")
        experts_config_content = """[Experts]
AllowLiveTrading=1
AllowDllImport=1
AllowWebRequest=1
AllowAutoTrading=1
AllowExternalExperts=1
AllowExternalSignals=1
AllowExternalAlerts=1
AllowSendNotifications=1
AllowSendEmail=1
AllowSendSMS=1
AllowSendPush=1
AllowSendWebRequest=1
AllowSendFTP=1
AllowSendTerminal=1
AllowSendTerminalEmail=1
AllowSendTerminalSMS=1
AllowSendTerminalPush=1
AllowSendTerminalWebRequest=1
AllowSendTerminalFTP=1
AllowSendTerminalTerminal=1
"""
        
        with open(experts_config_path, 'w', encoding='utf-8') as configfile:
            configfile.write(experts_config_content)
        
        print(f"‚úÖ Created experts.ini: {experts_config_path}")
        
        # 4. Create/update profiles.ini
        profiles_config_path = os.path.join(config_dir, "profiles.ini")
        profiles_config_content = """[Profiles]
Default=Default
"""
        
        with open(profiles_config_path, 'w', encoding='utf-8') as configfile:
            configfile.write(profiles_config_content)
        
        print(f"‚úÖ Created profiles.ini: {profiles_config_path}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Failed to create config files: {e}")
        return False

def enable_algo_trading_via_registry(terminal_path):
    """Enable algorithmic trading via Windows registry"""
    try:
        terminal_dir = os.path.dirname(terminal_path)
        registry_keys = [
            f"SOFTWARE\\MetaQuotes\\Terminal\\{terminal_dir.replace(':', '').replace('\\', '_')}",
            "SOFTWARE\\MetaQuotes\\Terminal",
            "SOFTWARE\\MetaQuotes\\Terminal\\Common",
            f"SOFTWARE\\MetaQuotes\\Terminal\\{os.path.basename(terminal_dir)}"
        ]
        
        for registry_key in registry_keys:
            try:
                with winreg.CreateKey(winreg.HKEY_CURRENT_USER, registry_key) as key:
                    winreg.SetValueEx(key, "AllowLiveTrading", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowDllImport", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowWebRequest", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowAutoTrading", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowExternalExperts", 0, winreg.REG_DWORD, 1)
                
                print(f"‚úÖ Algorithmic trading enabled in registry: {registry_key}")
                return True
                
            except Exception as e:
                continue
        
        print(f"‚ö†Ô∏è  Could not enable via registry for any key")
        return False
        
    except Exception as e:
        print(f"‚ö†Ô∏è  Could not enable via registry: {e}")
        return False

def save_login_credentials(terminal_path, login, password, server):
    """Save login credentials in MT5 terminal with comprehensive auto-login setup"""
    try:
        terminal_dir = os.path.dirname(terminal_path)
        config_dir = os.path.join(terminal_dir, "config")
        os.makedirs(config_dir, exist_ok=True)
        
        # Also try the common MT5 config location
        common_mt5_config = os.path.join(os.path.expanduser("~"), "AppData", "Roaming", "MetaQuotes", "Terminal")
        if os.path.exists(common_mt5_config):
            print(f"   üìÅ Found common MT5 config directory: {common_mt5_config}")
            # Create config files in both locations
            common_config_files = [config_dir, common_mt5_config]
        else:
            common_config_files = [config_dir]
        
        print(f"   üìÅ Creating config files in: {config_dir}")
        if len(common_config_files) > 1:
            print(f"   üìÅ Also creating in: {common_mt5_config}")
        
        # 1. Create/update accounts.ini
        for config_location in common_config_files:
            accounts_path = os.path.join(config_location, "accounts.ini")
            config = configparser.ConfigParser()
            if os.path.exists(accounts_path):
                config.read(accounts_path, encoding='utf-8')
            
            account_section = f"Account{login}"
            if account_section not in config:
                config[account_section] = {}
            
            config[account_section]['Login'] = str(login)
            config[account_section]['Password'] = password
            config[account_section]['Server'] = server
            config[account_section]['SavePassword'] = '1'
            config[account_section]['AutoLogin'] = '1'
            config[account_section]['AutoConnect'] = '1'
            config[account_section]['RememberPassword'] = '1'
            
            with open(accounts_path, 'w', encoding='utf-8') as configfile:
                config.write(configfile)
            
            print(f"   ‚úÖ Created accounts.ini in: {config_location}")
        
        # 2. Create/update common.ini with auto-login settings
        for config_location in common_config_files:
            common_path = os.path.join(config_location, "common.ini")
            common_config = configparser.ConfigParser()
            if os.path.exists(common_path):
                common_config.read(common_path, encoding='utf-8')
            
            if 'Terminal' not in common_config:
                common_config['Terminal'] = {}
            
            common_config['Terminal']['AutoLogin'] = '1'
            common_config['Terminal']['AutoConnect'] = '1'
            common_config['Terminal']['RememberPassword'] = '1'
            common_config['Terminal']['SavePassword'] = '1'
            common_config['Terminal']['AllowAutoLogin'] = '1'
            
            with open(common_path, 'w', encoding='utf-8') as configfile:
                common_config.write(configfile)
            
            print(f"   ‚úÖ Created common.ini in: {config_location}")
        
        # 3. Create/update terminal.ini
        for config_location in common_config_files:
            terminal_path_config = os.path.join(config_location, "terminal.ini")
            terminal_config = configparser.ConfigParser()
            if os.path.exists(terminal_path_config):
                terminal_config.read(terminal_path_config, encoding='utf-8')
            
            if 'Terminal' not in terminal_config:
                terminal_config['Terminal'] = {}
            
            terminal_config['Terminal']['AutoLogin'] = '1'
            terminal_config['Terminal']['AutoConnect'] = '1'
            terminal_config['Terminal']['RememberPassword'] = '1'
            terminal_config['Terminal']['SavePassword'] = '1'
            terminal_config['Terminal']['AllowAutoLogin'] = '1'
            
            with open(terminal_path_config, 'w', encoding='utf-8') as configfile:
                terminal_config.write(configfile)
            
            print(f"   ‚úÖ Created terminal.ini in: {config_location}")
        
        # 4. Create/update profiles.ini
        for config_location in common_config_files:
            profiles_path = os.path.join(config_location, "profiles.ini")
            profiles_config = configparser.ConfigParser()
            if os.path.exists(profiles_path):
                profiles_config.read(profiles_path, encoding='utf-8')
            
            if 'Profiles' not in profiles_config:
                profiles_config['Profiles'] = {}
            
            profiles_config['Profiles']['Default'] = 'Default'
            profiles_config['Profiles']['AutoLogin'] = '1'
            
            with open(profiles_path, 'w', encoding='utf-8') as configfile:
                profiles_config.write(configfile)
            
            print(f"   ‚úÖ Created profiles.ini in: {config_location}")
        
        print(f"‚úÖ Saved comprehensive login credentials for account {login}")
        print(f"   üìÅ Created/updated: accounts.ini, common.ini, terminal.ini, profiles.ini")
        
        # Verify files were created in all locations
        for config_location in common_config_files:
            print(f"   üìÅ Checking config files in: {config_location}")
            files_to_check = [
                os.path.join(config_location, "accounts.ini"),
                os.path.join(config_location, "common.ini"),
                os.path.join(config_location, "terminal.ini"),
                os.path.join(config_location, "profiles.ini")
            ]
            
            for file_path in files_to_check:
                if os.path.exists(file_path):
                    print(f"      ‚úÖ {os.path.basename(file_path)} exists")
                    # Show file contents for debugging
                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            print(f"      üìÑ {os.path.basename(file_path)} content:")
                            print(f"         {content.strip()}")
                    except Exception as e:
                        print(f"      ‚ùå Could not read {os.path.basename(file_path)}: {e}")
                else:
                    print(f"      ‚ùå {os.path.basename(file_path)} NOT created!")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Failed to save login credentials: {e}")
        return False

def start_mt5_terminal(path):
    """Start MT5 terminal in headless mode with auto-login flags"""
    try:
        # Kill any existing MT5 processes first
        try:
            subprocess.run(['taskkill', '/f', '/im', 'terminal64.exe'], 
                         capture_output=True, check=False)
            time.sleep(5)
            print(f"üîÑ Killed existing MT5 processes")
        except:
            pass
        
        # Launch with comprehensive flags for auto-login
        # /portable: Run in portable mode
        # /headless: Run without GUI
        # /login: Auto-login with saved credentials
        # /autotrading: Enable auto-trading
        subprocess.Popen([path, "/portable", "/headless", "/login", "/autotrading"])
        time.sleep(20)  # Give MT5 more time to start and auto-login
        print(f"‚úÖ Started MT5 terminal with auto-login flags: {path}")
    except Exception as e:
        print(f"‚ùå Error starting MT5 terminal: {e}")

def wait_for_terminal_ready(terminal_path, login, password, server, max_attempts=5):
    """Wait for terminal to be ready and connected"""
    print(f"‚è≥ Waiting for terminal to be ready...")
    
    # Ensure login is an integer
    try:
        login_int = int(login)
        print(f"   üî¢ Login converted to integer: {login_int}")
    except (ValueError, TypeError):
        print(f"   ‚ùå ERROR: Login '{login}' cannot be converted to integer!")
        print(f"   üîç Login type: {type(login)}")
        return False
    
    for attempt in range(max_attempts):
        try:
            print(f"üîê Attempt {attempt + 1}: Trying to login with credentials...")
            print(f"   Terminal: {terminal_path}")
            print(f"   Login: {login} (as integer: {login_int})")
            print(f"   Server: {server}")
            
            # Try to initialize with login
            print(f"   üì° Initializing MT5 connection...")
            if mt5.initialize(path=terminal_path, login=login_int, password=password, server=server):
                print(f"   ‚úÖ MT5.initialize() succeeded!")
                
                # Try to get account info
                print(f"   üìä Getting account info...")
                account_info = mt5.account_info()
                if account_info:
                    print(f"   ‚úÖ Account info retrieved successfully!")
                    print(f"   üìã Account details:")
                    print(f"      - Login: {account_info.login}")
                    print(f"      - Server: {account_info.server}")
                    print(f"      - Balance: {account_info.balance}")
                    print(f"      - Equity: {account_info.equity}")
                    print(f"‚úÖ Terminal ready! Account: {account_info.login}")
                    mt5.shutdown()
                    return True
                else:
                    print(f"   ‚ùå Account info is None - login may have failed")
                    print(f"   üîç Checking MT5 last error...")
                    error = mt5.last_error()
                    print(f"   üìù MT5 Error: {error}")
                    print(f"‚ö†Ô∏è  Terminal connected but no account info (attempt {attempt + 1})")
                    mt5.shutdown()
            else:
                print(f"   ‚ùå MT5.initialize() failed!")
                error = mt5.last_error()
                print(f"   üìù MT5 Error: {error}")
                print(f"‚ö†Ô∏è  Terminal not ready yet (attempt {attempt + 1})")
                
                # If this is a fresh terminal, the login dialog might be blocking
                if attempt == 0:
                    print(f"   üí° This appears to be a fresh terminal - login dialog may be blocking")
                    print(f"   üí° Checking if we can force the login process...")
                    
                    # Try to send Enter key to the terminal process to accept login
                    try:
                        # Find MT5 process and try to send Enter key
                        result = subprocess.run(['tasklist', '/FI', 'IMAGENAME eq terminal64.exe'], 
                                             capture_output=True, text=True, check=False)
                        if 'terminal64.exe' in result.stdout:
                            print(f"   üîç MT5 process is running, attempting to force login...")
                            # Try to send Enter key to the active window
                            if WIN32_AVAILABLE:
                                try:
                                    # Find MT5 window and send Enter
                                    def enum_windows_callback(hwnd, windows):
                                        if win32gui.IsWindowVisible(hwnd):
                                            window_text = win32gui.GetWindowText(hwnd)
                                            if 'MetaTrader' in window_text or 'Login' in window_text:
                                                windows.append(hwnd)
                                        return True
                                    
                                    windows = []
                                    win32gui.EnumWindows(enum_windows_callback, windows)
                                    
                                    if windows:
                                        print(f"   üéØ Found MT5 window, sending Enter key...")
                                        win32gui.SetForegroundWindow(windows[0])
                                        win32api.keybd_event(win32con.VK_RETURN, 0, 0, 0)
                                        win32api.keybd_event(win32con.VK_RETURN, 0, win32con.KEYEVENTF_KEYUP, 0)
                                        time.sleep(5)  # Wait for login to process
                                    else:
                                        print(f"   ‚ö†Ô∏è  No MT5 window found")
                                except Exception as e:
                                    print(f"   ‚ö†Ô∏è  Could not force login: {e}")
                            else:
                                print(f"   ‚ö†Ô∏è  win32gui not available, cannot force login")
                    except Exception as e:
                        print(f"   ‚ö†Ô∏è  Could not check MT5 process: {e}")
        except Exception as e:
            print(f"   ‚ùå Exception during login attempt: {e}")
            print(f"   üîç Exception type: {type(e).__name__}")
            print(f"‚ö†Ô∏è  Connection attempt {attempt + 1} failed: {e}")
            mt5.shutdown()
        
        print(f"   ‚è≥ Waiting 10 seconds before next attempt...")
        time.sleep(10)  # Wait 10 seconds between attempts for fresh terminals
    
    print(f"‚ùå Terminal not ready after {max_attempts} attempts")
    return False

def force_enable_autotrading_via_api(terminal_path, login, password, server):
    """Try to force enable AutoTrading via MT5 API"""
    try:
        # Ensure login is an integer
        login_int = int(login)
        if mt5.initialize(path=terminal_path, login=login_int, password=password, server=server):
            # Try to get terminal info and check if we can modify settings
            terminal_info = mt5.terminal_info()
            print(f"Terminal info - Trade allowed: {terminal_info.trade_allowed}")
            print(f"Terminal info - Connected: {terminal_info.connected}")
            
            # Try to get account info
            account_info = mt5.account_info()
            if account_info:
                print(f"Account info - Trade allowed: {account_info.trade_allowed}")
                print(f"Account info - Trade expert: {account_info.trade_expert}")
                print(f"Account info - Balance: {account_info.balance}")
                print(f"Account info - Equity: {account_info.equity}")
            
            mt5.shutdown()
            return True
        else:
            print(f"‚ùå Could not initialize MT5 for API access")
            mt5.shutdown()
            return False
    except Exception as e:
        print(f"‚ö†Ô∏è  Could not force enable via API: {e}")
        mt5.shutdown()
        return False

def check_autotrading_status(terminal_path, login, password, server):
    """Check if AutoTrading is currently enabled"""
    try:
        # Ensure login is an integer
        login_int = int(login)
        if mt5.initialize(path=terminal_path, login=login_int, password=password, server=server):
            terminal_info = mt5.terminal_info()
            mt5.shutdown()
            return terminal_info.trade_allowed
        else:
            mt5.shutdown()
            return False
    except Exception as e:
        print(f"‚ö†Ô∏è  Could not check AutoTrading status: {e}")
        mt5.shutdown()
        return False

def setup_single_terminal(terminal_path, login, password, server, terminal_name):
    """Setup a single terminal: launch, wait for connection, verify AutoTrading"""
    try:
        print(f"\n{'='*60}")
        print(f"üöÄ Setting up {terminal_name} terminal...")
        print(f"{'='*60}")
        
        # Step 1: Save credentials and launch terminal
        print(f"üìã Step 1: Saving credentials for {terminal_name}...")
        save_login_credentials(terminal_path, login, password, server)
        
        print(f"üöÄ Step 2: Launching {terminal_name} terminal...")
        start_mt5_terminal(terminal_path)
        
        # Step 3: Wait for terminal to be ready
        print(f"‚è≥ Step 3: Waiting for {terminal_name} terminal to be ready...")
        if not wait_for_terminal_ready(terminal_path, login, password, server):
            print(f"‚ùå {terminal_name} terminal not ready")
            return False
        
        # Step 4: Try to force enable AutoTrading via API
        print(f"üîß Step 4: Attempting to force enable AutoTrading for {terminal_name}...")
        force_enable_autotrading_via_api(terminal_path, login, password, server)
        
        # Step 4.5: Try to restart terminal to apply new config files
        print(f"üîÑ Step 4.5: Restarting terminal to apply new AutoTrading config...")
        try:
            # Kill existing process
            subprocess.run(['taskkill', '/f', '/im', 'terminal64.exe'], 
                         capture_output=True, check=False)
            time.sleep(5)
            
            # Restart with all flags
            subprocess.Popen([terminal_path, "/portable", "/headless", "/login", "/autotrading"])
            time.sleep(20)  # Give time for restart and config application
            
            print(f"‚úÖ Terminal restarted with new config")
        except Exception as e:
            print(f"‚ö†Ô∏è  Could not restart terminal: {e}")
        
        # Step 5: Verify AutoTrading is enabled
        print(f"‚úÖ Step 5: Verifying AutoTrading for {terminal_name}...")
        autotrading_enabled = False
        for attempt in range(10):  # Increased attempts
            try:
                if check_autotrading_status(terminal_path, login, password, server):
                    print(f"‚úÖ CONFIRMED: AutoTrading is ENABLED for {terminal_name}")
                    autotrading_enabled = True
                    break
                else:
                    print(f"‚ùå AutoTrading is DISABLED for {terminal_name} (attempt {attempt + 1})")
                    
                    # Try to restart terminal if AutoTrading is still disabled after several attempts
                    if attempt == 5:
                        print(f"üîÑ Attempting to restart {terminal_name} terminal to enable AutoTrading...")
                        # Kill existing process
                        try:
                            subprocess.run(['taskkill', '/f', '/im', 'terminal64.exe'], 
                                         capture_output=True, check=False)
                            time.sleep(5)
                        except:
                            pass
                        
                        # Restart with different flags
                        try:
                            subprocess.Popen([terminal_path, "/portable", "/headless", "/autotrading"])
                            time.sleep(15)
                        except:
                            pass
                    
            except Exception as e:
                print(f"‚ö†Ô∏è  AutoTrading verification attempt {attempt + 1} failed: {e}")
            
            if attempt < 9:  # Don't sleep after last attempt
                time.sleep(3)
        
        if not autotrading_enabled:
            print(f"‚ö†Ô∏è  AutoTrading could not be enabled for {terminal_name}, but continuing anyway...")
            # Don't exit, just continue with the setup
            return True
        
        return autotrading_enabled
        
    except Exception as e:
        print(f"‚ùå Error setting up {terminal_name} terminal: {e}")
        return False

def init_account(login, password, server, terminal_path):
    """Initialize MT5 account connection"""
    print(f"üîê Initializing account connection...")
    print(f"   Terminal: {terminal_path}")
    print(f"   Login: {login}")
    print(f"   Server: {server}")
    
    # Ensure login is an integer
    try:
        login_int = int(login)
        print(f"   üî¢ Login converted to integer: {login_int}")
    except (ValueError, TypeError):
        print(f"   ‚ùå ERROR: Login '{login}' cannot be converted to integer!")
        print(f"   üîç Login type: {type(login)}")
        return False
    
    if not mt5.initialize(path=terminal_path, login=login_int, password=password, server=server):
        error = mt5.last_error()
        print(f"‚ùå Failed to initialize MT5 account {login}")
        print(f"   üìù MT5 Error: {error}")
        return False
    
    print(f"   ‚úÖ MT5.initialize() succeeded!")
    
    account_info = mt5.account_info()
    if account_info:
        print(f"   ‚úÖ Account info retrieved successfully!")
        print(f"   üìã Account details:")
        print(f"      - Login: {account_info.login}")
        print(f"      - Server: {account_info.server}")
        print(f"      - Balance: {account_info.balance}")
        print(f"‚úÖ Account {login} logged in successfully")
        return True
    else:
        print(f"   ‚ùå Account info is None")
        error = mt5.last_error()
        print(f"   üìù MT5 Error: {error}")
        print(f"‚ùå Account {login} connected but no account info")
        mt5.shutdown()
        return False

def get_master_positions():
    """Get all open positions from master account"""
    return mt5.positions_get()

def get_safe_tick_price(symbol, order_type):
    """Get tick price with fallback to symbol info if tick is not available"""
    tick = mt5.symbol_info_tick(symbol)
    if tick is None:
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info is None:
            print(f"‚ùå Cannot get price info for {symbol}")
            return None
        
        if order_type == 0:  # BUY
            return symbol_info.ask
        else:  # SELL
            return symbol_info.bid
    else:
        if order_type == 0:  # BUY
            return tick.ask
        else:  # SELL
            return tick.bid

def copy_position_to_slave(position):
    """Copy a position from master to slave account"""
    symbol = position.symbol
    volume = position.volume
    order_type = position.type
    
    print(f"üîç Attempting to copy position to slave...")
    print(f"   Symbol: {symbol}")
    print(f"   Volume: {volume}")
    print(f"   Type: {'BUY' if order_type == 0 else 'SELL'}")
    
    # Check if we can get price info
    price = get_safe_tick_price(symbol, order_type)
    if price is None:
        print(f"‚ùå Cannot get price for {symbol}, skipping trade")
        return False
    
    print(f"   Price: {price}")

    # Check if we can actually trade on this account
    terminal_info = mt5.terminal_info()
    account_info = mt5.account_info()
    
    print(f"   Terminal trade allowed: {terminal_info.trade_allowed}")
    print(f"   Account trade allowed: {account_info.trade_allowed if account_info else 'N/A'}")
    
    if not terminal_info.trade_allowed:
        print(f"‚ùå Terminal trading is not allowed")
        return False
    
    if account_info and not account_info.trade_allowed:
        print(f"‚ùå Account trading is not allowed")
        return False

    request = { 
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": volume,
        "type": order_type,
        "price": price,
        "deviation": 10,
        "magic": 123456,
        "comment": "Trade copied",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_FOK,
    }

    print(f"   üì§ Sending trade request...")
    result = mt5.order_send(request)
    
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"‚ùå Trade failed: retcode={result.retcode}, message: {result.comment}")
        print(f"   üîç Full result: {result}")
        return False
    else:
        print(f"‚úÖ Trade copied successfully!")
        print(f"   üìã Trade details: {symbol}, {volume} lots, {'BUY' if order_type == 0 else 'SELL'}")
        print(f"   üé´ Ticket: {result.order}")
        return True

def positions_to_dict(positions):
    """Convert positions to a dictionary for comparison"""
    if positions is None:
        return {}
    return {(p.symbol, p.volume, p.type): p.ticket for p in positions}

def copy_trading_process(config):
    """Main copy trading process that runs continuously"""
    print("üéØ Starting copy trading process...")
    
    MASTER_LOGIN = config['MASTER_LOGIN']
    MASTER_PASSWORD = config['MASTER_PASSWORD']
    MASTER_SERVER = config['MASTER_SERVER']
    MASTER_PATH = config['MASTER_PATH']
    
    SLAVE_LOGIN = config['SLAVE_LOGIN']
    SLAVE_PASSWORD = config['SLAVE_PASSWORD']
    SLAVE_SERVER = config['SLAVE_SERVER']
    SLAVE_PATH = config['SLAVE_PATH']
    
    COPY_INTERVAL = config['COPY_INTERVAL']
    DISCORD_WEBHOOK_URL = config['DISCORD_WEBHOOK_URL']
    
    # Initialize baseline state - track existing positions when script starts
    baseline_master_positions = {}
    baseline_initialized = False
    
    # Add manual baseline reset option
    print("üí° To reset baseline and start fresh, press 'R' + Enter in the console")
    print("üí° This will clear all existing positions and start detecting new ones")
    
    while True:
        try:
            # Check for manual baseline reset
            try:
                import msvcrt
                if msvcrt.kbhit():
                    key = msvcrt.getch().decode('utf-8').upper()
                    if key == 'R':
                        print("\nüîÑ Manual baseline reset requested!")
                        baseline_master_positions = {}
                        baseline_initialized = False
                        print("üìä Baseline cleared - will reinitialize on next connection")
                        print("üí° Now open a new trade on master account to test copy trading")
            except:
                pass  # msvcrt not available on all systems
            
            # Connect to master terminal
            print(f"üîç Connecting to MASTER terminal...")
            if init_account(MASTER_LOGIN, MASTER_PASSWORD, MASTER_SERVER, MASTER_PATH):
                print("‚úÖ Connected to master")
                master_positions = get_master_positions()
                print(f"üìä Master positions: {len(master_positions) if master_positions else 0}")
                if master_positions:
                    print("üìã Master positions details:")
                    for pos in master_positions:
                        print(f"   - {pos.symbol}: {pos.volume} lots ({'BUY' if pos.type == 0 else 'SELL'}) - Ticket: {pos.ticket}")
                else:
                    print("üìã No master positions found")
                
                master_snapshot = positions_to_dict(master_positions)
                print(f"üìä Master snapshot: {len(master_snapshot)} positions")
                mt5.shutdown()
            else:
                print("‚ùå Failed to connect to master, retrying...")
                time.sleep(COPY_INTERVAL)
                continue

            # Connect to slave terminal
            print(f"üîç Connecting to SLAVE terminal...")
            if init_account(SLAVE_LOGIN, SLAVE_PASSWORD, SLAVE_SERVER, SLAVE_PATH):
                print("‚úÖ Connected to slave")
                slave_positions = get_master_positions()
                print(f"üìä Slave positions: {len(slave_positions) if slave_positions else 0}")
                if slave_positions:
                    print("üìã Slave positions details:")
                    for pos in slave_positions:
                        print(f"   - {pos.symbol}: {pos.volume} lots ({'BUY' if pos.type == 0 else 'SELL'}) - Ticket: {pos.ticket}")
                else:
                    print("üìã No slave positions found")
                
                slave_snapshot = positions_to_dict(slave_positions)
                print(f"üìä Slave snapshot: {len(slave_snapshot)} positions")

                # Initialize baseline on first successful connection
                if not baseline_initialized:
                    print("üìä Initializing baseline - recording existing positions...")
                    baseline_master_positions = master_snapshot.copy()
                    baseline_initialized = True
                    print(f"üìä Baseline initialized with {len(baseline_master_positions)} existing positions")
                    
                    # Show existing positions for reference
                    if baseline_master_positions:
                        print("üìã Existing positions (will NOT be copied):")
                        for pos_key in baseline_master_positions.keys():
                            symbol, volume, order_type = pos_key
                            print(f"   - {symbol}: {volume} lots ({'BUY' if order_type == 0 else 'SELL'})")
                    else:
                        print("üìã No existing positions found")
                    
                    # Send Discord notification about baseline initialization
                    send_discord_notification(
                        f"üìä Copy trading baseline initialized - {len(baseline_master_positions)} existing positions recorded",
                        DISCORD_WEBHOOK_URL
                    )
                    
                    print("üîÑ Baseline initialized - waiting for new positions...")
                    # Continue to next iteration without copying anything
                    mt5.shutdown()
                    time.sleep(COPY_INTERVAL)
                    continue

                # Check if we need to refresh baseline (if positions changed significantly)
                if len(master_snapshot) != len(baseline_master_positions):
                    print(f"üîÑ Position count changed: {len(baseline_master_positions)} -> {len(master_snapshot)}")
                    print(f"üîÑ Refreshing baseline to detect changes...")
                    baseline_master_positions = master_snapshot.copy()
                    print(f"üìä Baseline refreshed with {len(baseline_master_positions)} positions")
                    
                    # Continue to next iteration to let the refresh take effect
                    mt5.shutdown()
                    time.sleep(COPY_INTERVAL)
                    continue

                print(f"üîç Checking for new positions...")
                print(f"   Current master positions: {len(master_snapshot)}")
                print(f"   Baseline positions: {len(baseline_master_positions)}")
                print(f"   Current slave positions: {len(slave_snapshot)}")

                # Find truly new positions (positions in master that weren't in baseline)
                new_positions = {}
                print(f"üîç Analyzing position changes...")
                
                # Debug: Show what's in the baseline
                print(f"   üìä Baseline contains {len(baseline_master_positions)} positions:")
                for baseline_key in baseline_master_positions.keys():
                    symbol, volume, order_type = baseline_key
                    print(f"      - {symbol}: {volume} lots ({'BUY' if order_type == 0 else 'SELL'})")
                
                print(f"   üìä Current master has {len(master_snapshot)} positions:")
                for current_key in master_snapshot.keys():
                    symbol, volume, order_type = current_key
                    print(f"      - {symbol}: {volume} lots ({'BUY' if order_type == 0 else 'SELL'})")
                
                for pos_key, master_ticket in master_snapshot.items():
                    symbol, volume, order_type = pos_key
                    if pos_key not in baseline_master_positions:
                        new_positions[pos_key] = master_ticket
                        print(f"   üÜï NEW position detected: {symbol} {volume} lots ({'BUY' if order_type == 0 else 'SELL'})")
                    else:
                        print(f"   ‚úÖ Existing position: {symbol} {volume} lots ({'BUY' if order_type == 0 else 'SELL'})")
                        print(f"      üîç This position was already in baseline")

                if new_positions:
                    print(f"üéØ Found {len(new_positions)} new positions to copy")
                    # Copy only the new positions
                    for p in master_positions:
                        pos_key = (p.symbol, p.volume, p.type)
                        if pos_key in new_positions:
                            print(f"üìà Copying new position: {p.symbol} {p.volume} lots ({'BUY' if p.type == 0 else 'SELL'})")
                            if copy_position_to_slave(p):
                                send_discord_notification(
                                    f"‚úÖ Trade copied: {p.symbol} {p.volume} lots ({'BUY' if p.type == 0 else 'SELL'})",
                                    DISCORD_WEBHOOK_URL
                                )
                else:
                    print("‚úÖ No new positions to copy")
                    print("   üí° This means all current master positions were already in the baseline")

                # Update baseline to include any new positions we just copied
                # This prevents re-copying the same position if the script restarts
                if new_positions:
                    print(f"üîÑ Updating baseline with {len(new_positions)} new positions...")
                    baseline_master_positions.update(new_positions)
                    print(f"üìä Baseline now contains {len(baseline_master_positions)} positions")
                else:
                    print(f"üìä Baseline unchanged - no new positions to add")
                
                mt5.shutdown()
            else:
                print("‚ùå Failed to connect to slave, retrying...")
                time.sleep(COPY_INTERVAL)
                continue

        except Exception as e:
            print(f"‚ùå Error in copy trading process: {e}")
            mt5.shutdown()
        
        time.sleep(COPY_INTERVAL)

if __name__ == "__main__":
    print("üöÄ Starting Dynamic MT5 Copy Trading...")
    
    # Get user ID from EC2 metadata or environment
    user_id = get_user_id_from_ec2()
    if user_id is None:
        print("‚ùå Could not determine user ID. Exiting.")
        sys.exit(1)
    
    print(f"üë§ Trading for user ID: {user_id}")
    
    # Load configuration from database
    config = load_configuration_from_database(user_id)
    
    if config is None:
        print("‚ùå No valid account configuration found in database.")
        print("‚è≥ Waiting for accounts to be added in dashboard...")
        
        # Wait for configuration in a loop
        while True:
            time.sleep(30)  # Check every 30 seconds
            print("üîÑ Checking database for account configuration...")
            config = load_configuration_from_database(user_id)
            if config is not None:
                print("‚úÖ Account configuration found in database!")
                break
    
    print(f"\n{'='*60}")
    print("üìã Current Configuration:")
    print(f"Master Account: {config['MASTER_LOGIN']}")
    print(f"Slave Account: {config['SLAVE_LOGIN']}")
    print(f"Copy Interval: {config['COPY_INTERVAL']} seconds")
    print(f"{'='*60}")
    
    # Send Discord notification
    send_discord_notification(
        f"üöÄ Dynamic Copy Trading started - Master: {config['MASTER_LOGIN']}, Slave: {config['SLAVE_LOGIN']}",
        config['DISCORD_WEBHOOK_URL']
    )
    
    # Setup terminals
    print(f"\nüöÄ Setting up terminals...")
    
    master_success = setup_single_terminal(
        config['MASTER_PATH'], 
        config['MASTER_LOGIN'], 
        config['MASTER_PASSWORD'], 
        config['MASTER_SERVER'], 
        "Master"
    )
    
    slave_success = setup_single_terminal(
        config['SLAVE_PATH'], 
        config['SLAVE_LOGIN'], 
        config['SLAVE_PASSWORD'], 
        config['SLAVE_SERVER'], 
        "Slave"
    )
    
    if master_success and slave_success:
        print(f"\nüéØ Both terminals ready! Starting copy trading...")
        send_discord_notification(
            f"‚úÖ Dynamic Copy Trading ready - Both terminals active!",
            config['DISCORD_WEBHOOK_URL']
        )
        
        try:
            copy_trading_process(config)
        except KeyboardInterrupt:
            send_discord_notification("‚èπÔ∏è Dynamic Copy Trading stopped by user", config['DISCORD_WEBHOOK_URL'])
            print("\nCopy trading stopped by user")
            mt5.shutdown()
        except Exception as e:
            send_discord_notification(f"‚ùå Dynamic Copy Trading error: {str(e)}", config['DISCORD_WEBHOOK_URL'])
            print(f"Error: {e}")
            mt5.shutdown()
    else:
        print("‚ùå Failed to setup terminals")
        send_discord_notification("‚ùå Failed to setup MT5 terminals", config['DISCORD_WEBHOOK_URL'])
