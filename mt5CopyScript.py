"""
Dynamic Copy Trading Script
This script loads account configurations dynamically from the config file
generated by the EC2 account server.
"""

import MetaTrader5 as mt5
import subprocess
import time
import multiprocessing
import sys
import os
import configparser
import winreg
import requests
import json
from datetime import datetime

# Default paths and settings (non-account specific)
DEFAULT_CONFIG = {
    "MASTER_PATH": r"C:\Users\Administrator\Desktop\terminals\master\terminal64.exe",
    "SLAVE_PATH": r"C:\Users\Administrator\Desktop\terminals\slave1\terminal64.exe",
    "COPY_INTERVAL": 1,
    "DISCORD_WEBHOOK_URL": "https://discord.com/api/webhooks/1405657359438712903/3SR_iC1jWXOckZKRLv73Gg_l0_3v02v1vEZVwOclXfupq-jN2pUt3GFqLYzTNJZUjFCx"
}

def load_configuration():
    """Load configuration from the dynamic config file - no fallback accounts"""
    config_file = "/home/ubuntu/copy_trading_config.py"
    accounts_file = "/home/ubuntu/trading_accounts.json"
    
    config = DEFAULT_CONFIG.copy()
    account_found = False
    
    try:
        # Try to load from the Python config file first
        if os.path.exists(config_file):
            print(f"üìã Loading configuration from: {config_file}")
            
            # Execute the config file to get variables
            exec_globals = {}
            with open(config_file, 'r') as f:
                exec(f.read(), exec_globals)
            
            # Update config with loaded values
            for key in ['MASTER_LOGIN', 'MASTER_PASSWORD', 'MASTER_SERVER', 'SLAVE_LOGIN', 'SLAVE_PASSWORD', 'SLAVE_SERVER']:
                if key in exec_globals:
                    config[key] = exec_globals[key]
                    print(f"‚úÖ Loaded {key}: {exec_globals[key] if 'PASSWORD' not in key else '***'}")
                    account_found = True
            
            # Load other config values
            for key in DEFAULT_CONFIG.keys():
                if key in exec_globals:
                    config[key] = exec_globals[key]
        
        # Also try to load from JSON file for additional info
        elif os.path.exists(accounts_file):
            print(f"üìã Loading configuration from JSON: {accounts_file}")
            
            with open(accounts_file, 'r') as f:
                json_config = json.load(f)
            
            # Map JSON config to script config
            if 'masterAccount' in json_config:
                master = json_config['masterAccount']
                config['MASTER_LOGIN'] = int(master.get('login'))
                config['MASTER_PASSWORD'] = master.get('password')
                config['MASTER_SERVER'] = master.get('server')
                account_found = True
            
            if 'slaveAccounts' in json_config and len(json_config['slaveAccounts']) > 0:
                slave = json_config['slaveAccounts'][0]  # Use first slave
                config['SLAVE_LOGIN'] = int(slave.get('login'))
                config['SLAVE_PASSWORD'] = slave.get('password')
                config['SLAVE_SERVER'] = slave.get('server')
                account_found = True
            
            print(f"‚úÖ Loaded from JSON - Master: {config.get('MASTER_LOGIN')}, Slave: {config.get('SLAVE_LOGIN')}")
        
        else:
            print("‚ùå No configuration file found")
            return None
            
    except Exception as e:
        print(f"‚ùå Error loading configuration: {e}")
        return None
    
    # Validate that we have the required account information
    required_fields = ['MASTER_LOGIN', 'MASTER_PASSWORD', 'MASTER_SERVER', 'SLAVE_LOGIN', 'SLAVE_PASSWORD', 'SLAVE_SERVER']
    missing_fields = [field for field in required_fields if field not in config or not config[field]]
    
    if missing_fields:
        print(f"‚ùå Missing required account configuration: {missing_fields}")
        return None
    
    if not account_found:
        print("‚ùå No account configuration found")
        return None
    
    return config

def send_discord_notification(message, webhook_url):
    """Send notification to Discord"""
    try:
        payload = {
            "content": message,
            "username": "MT5 Copy Trading Bot"
        }
        
        response = requests.post(webhook_url, json=payload)
        if response.status_code == 204:
            print(f"‚úÖ Discord notification sent: {message}")
        else:
            print(f"‚ùå Failed to send Discord notification: {response.status_code}")
    except Exception as e:
        print(f"‚ùå Failed to send Discord notification: {e}")

def enable_algo_trading_in_config(terminal_path):
    """Enable algorithmic trading by creating comprehensive config files"""
    try:
        terminal_dir = os.path.dirname(terminal_path)
        config_dir = os.path.join(terminal_dir, "config")
        os.makedirs(config_dir, exist_ok=True)
        
        config_content = """[Terminal]
AllowLiveTrading=1
AllowDllImport=1
AllowWebRequest=1
AllowAutoTrading=1
AllowExternalExperts=1
AllowExternalSignals=1
AllowExternalAlerts=1
"""
        
        config_files = ["common.ini", "terminal.ini", "experts.ini"]
        
        for config_file in config_files:
            config_path = os.path.join(config_dir, config_file)
            with open(config_path, 'w', encoding='utf-8') as f:
                f.write(config_content)
            print(f"‚úÖ Created {config_file}: {config_path}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Failed to create config files: {e}")
        return False

def enable_algo_trading_via_registry(terminal_path):
    """Enable algorithmic trading via Windows registry"""
    try:
        terminal_dir = os.path.dirname(terminal_path)
        registry_keys = [
            f"SOFTWARE\\MetaQuotes\\Terminal\\{terminal_dir.replace(':', '').replace('\\', '_')}",
            "SOFTWARE\\MetaQuotes\\Terminal",
            "SOFTWARE\\MetaQuotes\\Terminal\\Common",
            f"SOFTWARE\\MetaQuotes\\Terminal\\{os.path.basename(terminal_dir)}"
        ]
        
        for registry_key in registry_keys:
            try:
                with winreg.CreateKey(winreg.HKEY_CURRENT_USER, registry_key) as key:
                    winreg.SetValueEx(key, "AllowLiveTrading", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowDllImport", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowWebRequest", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowAutoTrading", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowExternalExperts", 0, winreg.REG_DWORD, 1)
                
                print(f"‚úÖ Algorithmic trading enabled in registry: {registry_key}")
                return True
                
            except Exception as e:
                continue
        
        print(f"‚ö†Ô∏è  Could not enable via registry for any key")
        return False
        
    except Exception as e:
        print(f"‚ö†Ô∏è  Could not enable via registry: {e}")
        return False

def save_login_credentials(terminal_path, login, password, server):
    """Save login credentials in MT5 terminal"""
    try:
        terminal_dir = os.path.dirname(terminal_path)
        config_dir = os.path.join(terminal_dir, "config")
        os.makedirs(config_dir, exist_ok=True)
        
        accounts_path = os.path.join(config_dir, "accounts.ini")
        
        config = configparser.ConfigParser()
        if os.path.exists(accounts_path):
            config.read(accounts_path, encoding='utf-8')
        
        account_section = f"Account{login}"
        if account_section not in config:
            config[account_section] = {}
        
        config[account_section]['Login'] = str(login)
        config[account_section]['Password'] = password
        config[account_section]['Server'] = server
        config[account_section]['SavePassword'] = '1'
        config[account_section]['AutoLogin'] = '1'
        
        with open(accounts_path, 'w', encoding='utf-8') as configfile:
            config.write(configfile)
        
        print(f"‚úÖ Saved login credentials for account {login}")
        return True
        
    except Exception as e:
        print(f"‚ùå Failed to save login credentials: {e}")
        return False

def start_mt5_terminal(path, login, password, server):
    """Start MT5 terminal in headless mode"""
    try:
        save_login_credentials(path, login, password, server)
        enable_algo_trading_in_config(path)
        enable_algo_trading_via_registry(path)
        
        subprocess.Popen([path, "/portable", "/headless"])
        time.sleep(10)
        print(f"‚úÖ Started MT5 terminal: {path}")
    except Exception as e:
        print(f"‚ùå Error starting MT5 terminal: {e}")

def wait_for_terminal_ready(terminal_path, login, password, server, max_attempts=30):
    """Wait for terminal to be ready and connected"""
    print(f"‚è≥ Waiting for terminal to be ready...")
    
    for attempt in range(max_attempts):
        try:
            if mt5.initialize(path=terminal_path, login=login, password=password, server=server):
                account_info = mt5.account_info()
                if account_info:
                    print(f"‚úÖ Terminal ready! Account: {account_info.login}")
                    mt5.shutdown()
                    return True
                else:
                    print(f"‚ö†Ô∏è  Terminal connected but no account info (attempt {attempt + 1})")
                    mt5.shutdown()
            else:
                print(f"‚ö†Ô∏è  Terminal not ready yet (attempt {attempt + 1})")
        except Exception as e:
            print(f"‚ö†Ô∏è  Connection attempt {attempt + 1} failed: {e}")
            mt5.shutdown()
        
        time.sleep(5)
    
    print(f"‚ùå Terminal not ready after {max_attempts} attempts")
    return False

def setup_single_terminal(terminal_path, login, password, server, terminal_name):
    """Setup a single terminal"""
    try:
        print(f"\n{'='*60}")
        print(f"üöÄ Setting up {terminal_name} terminal...")
        print(f"Account: {login}")
        print(f"{'='*60}")
        
        print(f"üìã Step 1: Saving credentials for {terminal_name}...")
        save_login_credentials(terminal_path, login, password, server)
        
        print(f"üöÄ Step 2: Launching {terminal_name} terminal...")
        start_mt5_terminal(terminal_path, login, password, server)
        
        print(f"‚è≥ Step 3: Waiting for {terminal_name} terminal to be ready...")
        if not wait_for_terminal_ready(terminal_path, login, password, server):
            print(f"‚ùå {terminal_name} terminal not ready")
            return False
        
        print(f"‚úÖ {terminal_name} terminal setup complete!")
        return True
        
    except Exception as e:
        print(f"‚ùå Error setting up {terminal_name} terminal: {e}")
        return False

def init_account(login, password, server, terminal_path):
    """Initialize MT5 account connection"""
    if not mt5.initialize(path=terminal_path, login=login, password=password, server=server):
        print(f"‚ùå Failed to initialize MT5 account {login}: {mt5.last_error()}")
        return False
    
    account_info = mt5.account_info()
    if account_info:
        print(f"‚úÖ Account {login} logged in successfully")
        return True
    else:
        print(f"‚ùå Account {login} connected but no account info")
        mt5.shutdown()
        return False

def get_master_positions():
    """Get all open positions from master account"""
    return mt5.positions_get()

def get_safe_tick_price(symbol, order_type):
    """Get tick price with fallback to symbol info if tick is not available"""
    tick = mt5.symbol_info_tick(symbol)
    if tick is None:
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info is None:
            print(f"‚ùå Cannot get price info for {symbol}")
            return None
        
        if order_type == 0:  # BUY
            return symbol_info.ask
        else:  # SELL
            return symbol_info.bid
    else:
        if order_type == 0:  # BUY
            return tick.ask
        else:  # SELL
            return tick.bid

def copy_position_to_slave(position):
    """Copy a position from master to slave account"""
    symbol = position.symbol
    volume = position.volume
    order_type = position.type
    
    price = get_safe_tick_price(symbol, order_type)
    if price is None:
        print(f"‚ùå Cannot get price for {symbol}, skipping trade")
        return False

    request = { 
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": volume,
        "type": order_type,
        "price": price,
        "deviation": 10,
        "magic": 123456,
        "comment": "Trade copied",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_FOK,
    }

    result = mt5.order_send(request)
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"‚ùå Trade failed: retcode={result.retcode}, message: {result.comment}")
        return False
    else:
        print(f"‚úÖ Trade copied: {symbol}, {volume} lots, {'BUY' if order_type == 0 else 'SELL'}")
        return True

def positions_to_dict(positions):
    """Convert positions to a dictionary for comparison"""
    if positions is None:
        return {}
    return {(p.symbol, p.volume, p.type): p.ticket for p in positions}

def copy_trading_process(config):
    """Main copy trading process that runs continuously"""
    print("üéØ Starting copy trading process...")
    
    MASTER_LOGIN = config['MASTER_LOGIN']
    MASTER_PASSWORD = config['MASTER_PASSWORD']
    MASTER_SERVER = config['MASTER_SERVER']
    MASTER_PATH = config['MASTER_PATH']
    
    SLAVE_LOGIN = config['SLAVE_LOGIN']
    SLAVE_PASSWORD = config['SLAVE_PASSWORD']
    SLAVE_SERVER = config['SLAVE_SERVER']
    SLAVE_PATH = config['SLAVE_PATH']
    
    COPY_INTERVAL = config['COPY_INTERVAL']
    DISCORD_WEBHOOK_URL = config['DISCORD_WEBHOOK_URL']
    
    baseline_master_positions = {}
    baseline_initialized = False
    
    while True:
        try:
            # Connect to master terminal
            if init_account(MASTER_LOGIN, MASTER_PASSWORD, MASTER_SERVER, MASTER_PATH):
                master_positions = get_master_positions()
                master_snapshot = positions_to_dict(master_positions)
                mt5.shutdown()
            else:
                print("‚ùå Failed to connect to master, retrying...")
                time.sleep(COPY_INTERVAL)
                continue

            # Connect to slave terminal
            if init_account(SLAVE_LOGIN, SLAVE_PASSWORD, SLAVE_SERVER, SLAVE_PATH):
                slave_positions = get_master_positions()
                slave_snapshot = positions_to_dict(slave_positions)

                # Initialize baseline on first successful connection
                if not baseline_initialized:
                    print("üìä Initializing baseline - recording existing positions...")
                    baseline_master_positions = master_snapshot.copy()
                    baseline_initialized = True
                    print(f"üìä Baseline initialized with {len(baseline_master_positions)} existing positions")
                    
                    mt5.shutdown()
                    time.sleep(COPY_INTERVAL)
                    continue

                # Find new positions
                new_positions = {}
                for pos_key, master_ticket in master_snapshot.items():
                    if pos_key not in baseline_master_positions:
                        new_positions[pos_key] = master_ticket

                if new_positions:
                    print(f"üéØ Found {len(new_positions)} new positions to copy")
                    for p in master_positions:
                        pos_key = (p.symbol, p.volume, p.type)
                        if pos_key in new_positions:
                            print(f"üìà Copying new position: {p.symbol} {p.volume} lots ({'BUY' if p.type == 0 else 'SELL'})")
                            if copy_position_to_slave(p):
                                send_discord_notification(
                                    f"‚úÖ Trade copied: {p.symbol} {p.volume} lots ({'BUY' if p.type == 0 else 'SELL'})",
                                    DISCORD_WEBHOOK_URL
                                )

                # Update baseline
                baseline_master_positions.update(new_positions)
                
                mt5.shutdown()
            else:
                print("‚ùå Failed to connect to slave, retrying...")
                time.sleep(COPY_INTERVAL)
                continue

        except Exception as e:
            print(f"‚ùå Error in copy trading process: {e}")
            mt5.shutdown()
        
        time.sleep(COPY_INTERVAL)

if __name__ == "__main__":
    print("üöÄ Starting Dynamic MT5 Copy Trading...")
    
    # Load configuration
    config = load_configuration()
    
    if config is None:
        print("‚ùå No valid account configuration found.")
        print("‚è≥ Waiting for account configuration to be sent from dashboard...")
        
        # Wait for configuration in a loop
        while True:
            time.sleep(30)  # Check every 30 seconds
            print("üîÑ Checking for account configuration...")
            config = load_configuration()
            if config is not None:
                print("‚úÖ Account configuration received!")
                break
    
    print(f"\n{'='*60}")
    print("üìã Current Configuration:")
    print(f"Master Account: {config['MASTER_LOGIN']}")
    print(f"Slave Account: {config['SLAVE_LOGIN']}")
    print(f"Copy Interval: {config['COPY_INTERVAL']} seconds")
    print(f"{'='*60}")
    
    # Send Discord notification
    send_discord_notification(
        f"üöÄ Dynamic Copy Trading started - Master: {config['MASTER_LOGIN']}, Slave: {config['SLAVE_LOGIN']}",
        config['DISCORD_WEBHOOK_URL']
    )
    
    # Setup terminals
    print(f"\nüöÄ Setting up terminals...")
    
    master_success = setup_single_terminal(
        config['MASTER_PATH'], 
        config['MASTER_LOGIN'], 
        config['MASTER_PASSWORD'], 
        config['MASTER_SERVER'], 
        "Master"
    )
    
    slave_success = setup_single_terminal(
        config['SLAVE_PATH'], 
        config['SLAVE_LOGIN'], 
        config['SLAVE_PASSWORD'], 
        config['SLAVE_SERVER'], 
        "Slave"
    )
    
    if master_success and slave_success:
        print(f"\nüéØ Both terminals ready! Starting copy trading...")
        send_discord_notification(
            f"‚úÖ Dynamic Copy Trading ready - Both terminals active!",
            config['DISCORD_WEBHOOK_URL']
        )
        
        try:
            copy_trading_process(config)
        except KeyboardInterrupt:
            send_discord_notification("‚èπÔ∏è Dynamic Copy Trading stopped by user", config['DISCORD_WEBHOOK_URL'])
            print("\nCopy trading stopped by user")
            mt5.shutdown()
        except Exception as e:
            send_discord_notification(f"‚ùå Dynamic Copy Trading error: {str(e)}", config['DISCORD_WEBHOOK_URL'])
            print(f"Error: {e}")
            mt5.shutdown()
    else:
        print("‚ùå Failed to setup terminals")
        send_discord_notification("‚ùå Failed to setup MT5 terminals", config['DISCORD_WEBHOOK_URL'])
