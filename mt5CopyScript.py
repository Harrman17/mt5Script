"""
Dynamic Copy Trading Script
This script loads account configurations dynamically from the config file
generated by the EC2 account server.
"""

import MetaTrader5 as mt5
import subprocess
import time
import multiprocessing
import sys
import os
import configparser
import winreg
import requests
import json
import psycopg2
from datetime import datetime

# Default paths and settings (non-account specific)
DEFAULT_CONFIG = {
    "MASTER_PATH": r"C:\Users\Administrator\Desktop\terminals\master\terminal64.exe",
    "SLAVE_PATH": r"C:\Users\Administrator\Desktop\terminals\slave1\terminal64.exe",
    "COPY_INTERVAL": 1,
    "DISCORD_WEBHOOK_URL": "https://discord.com/api/webhooks/1405657359438712903/3SR_iC1jWXOckZKRLv73Gg_l0_3v02v1vEZVwOclXfupq-jN2pUt3GFqLYzTNJZUjFCx"
}

def load_configuration_from_database(user_id):
    """Load configuration directly from the database"""
    config = DEFAULT_CONFIG.copy()
    
    try:
        # Database connection parameters - you'll need to set these
        # You can pass these as environment variables to the EC2
        conn = psycopg2.connect(
            host=os.environ.get('DB_HOST', 'localhost'),
            database=os.environ.get('DB_NAME', 'localmultitrader'),
            user=os.environ.get('DB_USER', 'harman'),
            password=os.environ.get('DB_PASSWORD', ''),
            port=os.environ.get('DB_PORT', '5432')
        )
        
        cursor = conn.cursor()
        
        # Get user's active accounts
        cursor.execute("""
            SELECT account_login, account_password, account_server, account_is_master 
            FROM accounts 
            WHERE user_id = %s AND is_active = true
            ORDER BY account_is_master DESC
        """, (user_id,))
        
        accounts = cursor.fetchall()
        
        if not accounts:
            print(f"‚ùå No active accounts found for user {user_id}")
            return None
        
        # Separate master and slave accounts
        master_account = None
        slave_accounts = []
        
        for login, password, server, is_master in accounts:
            if is_master:
                master_account = (login, password, server)
            else:
                slave_accounts.append((login, password, server))
        
        if not master_account:
            print(f"‚ùå No master account found for user {user_id}")
            return None
            
        if not slave_accounts:
            print(f"‚ùå No slave accounts found for user {user_id}")
            return None
        
        # Set master account
        config['MASTER_LOGIN'] = master_account[0]
        config['MASTER_PASSWORD'] = master_account[1]
        config['MASTER_SERVER'] = master_account[2]
        
        # Set first slave account (you can extend this for multiple slaves later)
        config['SLAVE_LOGIN'] = slave_accounts[0][0]
        config['SLAVE_PASSWORD'] = slave_accounts[0][1]
        config['SLAVE_SERVER'] = slave_accounts[0][2]
        
        # Store all slave accounts for future use
        config['ALL_SLAVE_ACCOUNTS'] = slave_accounts
        
        print(f"‚úÖ Loaded from database - User: {user_id}")
        print(f"üéØ Master: {config['MASTER_LOGIN']}")
        print(f"üéØ Slaves: {len(slave_accounts)}")
        
        cursor.close()
        conn.close()
        
        return config
        
    except Exception as e:
        print(f"‚ùå Error loading configuration from database: {e}")
        return None

def get_user_id_from_ec2():
    """Get the user ID from EC2 instance metadata or environment variable"""
    try:
        # Try to get from environment variable first
        user_id = os.environ.get('TRADING_USER_ID')
        if user_id:
            return int(user_id)
        
        # Try to get from EC2 instance tags
        import boto3
        ec2 = boto3.client('ec2', region_name=os.environ.get('AWS_REGION', 'us-east-1'))
        
        # Get instance ID
        response = requests.get('http://169.254.169.254/latest/meta-data/instance-id', timeout=5)
        instance_id = response.text
        
        # Get instance tags
        response = ec2.describe_instances(InstanceIds=[instance_id])
        tags = response['Reservations'][0]['Instances'][0].get('Tags', [])
        
        for tag in tags:
            if tag['Key'] == 'User':
                return int(tag['Value'])
        
        print("‚ùå No user ID found in environment or EC2 tags")
        return None
        
    except Exception as e:
        print(f"‚ùå Error getting user ID: {e}")
        return None

def send_discord_notification(message, webhook_url):
    """Send notification to Discord"""
    try:
        payload = {
            "content": message,
            "username": "MT5 Copy Trading Bot"
        }
        
        response = requests.post(webhook_url, json=payload)
        if response.status_code == 204:
            print(f"‚úÖ Discord notification sent: {message}")
        else:
            print(f"‚ùå Failed to send Discord notification: {response.status_code}")
    except Exception as e:
        print(f"‚ùå Failed to send Discord notification: {e}")

def enable_algo_trading_in_config(terminal_path):
    """Enable algorithmic trading by creating comprehensive config files"""
    try:
        terminal_dir = os.path.dirname(terminal_path)
        config_dir = os.path.join(terminal_dir, "config")
        os.makedirs(config_dir, exist_ok=True)
        
        config_content = """[Terminal]
AllowLiveTrading=1
AllowDllImport=1
AllowWebRequest=1
AllowAutoTrading=1
AllowExternalExperts=1
AllowExternalSignals=1
AllowExternalAlerts=1
"""
        
        config_files = ["common.ini", "terminal.ini", "experts.ini"]
        
        for config_file in config_files:
            config_path = os.path.join(config_dir, config_file)
            with open(config_path, 'w', encoding='utf-8') as f:
                f.write(config_content)
            print(f"‚úÖ Created {config_file}: {config_path}")
        
        return True
        
    except Exception as e:
        print(f"‚ùå Failed to create config files: {e}")
        return False

def enable_algo_trading_via_registry(terminal_path):
    """Enable algorithmic trading via Windows registry"""
    try:
        terminal_dir = os.path.dirname(terminal_path)
        registry_keys = [
            f"SOFTWARE\\MetaQuotes\\Terminal\\{terminal_dir.replace(':', '').replace('\\', '_')}",
            "SOFTWARE\\MetaQuotes\\Terminal",
            "SOFTWARE\\MetaQuotes\\Terminal\\Common",
            f"SOFTWARE\\MetaQuotes\\Terminal\\{os.path.basename(terminal_dir)}"
        ]
        
        for registry_key in registry_keys:
            try:
                with winreg.CreateKey(winreg.HKEY_CURRENT_USER, registry_key) as key:
                    winreg.SetValueEx(key, "AllowLiveTrading", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowDllImport", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowWebRequest", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowAutoTrading", 0, winreg.REG_DWORD, 1)
                    winreg.SetValueEx(key, "AllowExternalExperts", 0, winreg.REG_DWORD, 1)
                
                print(f"‚úÖ Algorithmic trading enabled in registry: {registry_key}")
                return True
                
            except Exception as e:
                continue
        
        print(f"‚ö†Ô∏è  Could not enable via registry for any key")
        return False
        
    except Exception as e:
        print(f"‚ö†Ô∏è  Could not enable via registry: {e}")
        return False

def save_login_credentials(terminal_path, login, password, server):
    """Save login credentials in MT5 terminal"""
    try:
        terminal_dir = os.path.dirname(terminal_path)
        config_dir = os.path.join(terminal_dir, "config")
        os.makedirs(config_dir, exist_ok=True)
        
        accounts_path = os.path.join(config_dir, "accounts.ini")
        
        config = configparser.ConfigParser()
        if os.path.exists(accounts_path):
            config.read(accounts_path, encoding='utf-8')
        
        account_section = f"Account{login}"
        if account_section not in config:
            config[account_section] = {}
        
        config[account_section]['Login'] = str(login)
        config[account_section]['Password'] = password
        config[account_section]['Server'] = server
        config[account_section]['SavePassword'] = '1'
        config[account_section]['AutoLogin'] = '1'
        
        with open(accounts_path, 'w', encoding='utf-8') as configfile:
            config.write(configfile)
        
        print(f"‚úÖ Saved login credentials for account {login}")
        return True
        
    except Exception as e:
        print(f"‚ùå Failed to save login credentials: {e}")
        return False

def start_mt5_terminal(path, login, password, server):
    """Start MT5 terminal in headless mode"""
    try:
        save_login_credentials(path, login, password, server)
        enable_algo_trading_in_config(path)
        enable_algo_trading_via_registry(path)
        
        subprocess.Popen([path, "/portable", "/headless"])
        time.sleep(10)
        print(f"‚úÖ Started MT5 terminal: {path}")
    except Exception as e:
        print(f"‚ùå Error starting MT5 terminal: {e}")

def wait_for_terminal_ready(terminal_path, login, password, server, max_attempts=30):
    """Wait for terminal to be ready and connected"""
    print(f"‚è≥ Waiting for terminal to be ready...")
    
    for attempt in range(max_attempts):
        try:
            if mt5.initialize(path=terminal_path, login=login, password=password, server=server):
                account_info = mt5.account_info()
                if account_info:
                    print(f"‚úÖ Terminal ready! Account: {account_info.login}")
                    mt5.shutdown()
                    return True
                else:
                    print(f"‚ö†Ô∏è  Terminal connected but no account info (attempt {attempt + 1})")
                    mt5.shutdown()
            else:
                print(f"‚ö†Ô∏è  Terminal not ready yet (attempt {attempt + 1})")
        except Exception as e:
            print(f"‚ö†Ô∏è  Connection attempt {attempt + 1} failed: {e}")
            mt5.shutdown()
        
        time.sleep(5)
    
    print(f"‚ùå Terminal not ready after {max_attempts} attempts")
    return False

def setup_single_terminal(terminal_path, login, password, server, terminal_name):
    """Setup a single terminal"""
    try:
        print(f"\n{'='*60}")
        print(f"üöÄ Setting up {terminal_name} terminal...")
        print(f"Account: {login}")
        print(f"{'='*60}")
        
        print(f"üìã Step 1: Saving credentials for {terminal_name}...")
        save_login_credentials(terminal_path, login, password, server)
        
        print(f"üöÄ Step 2: Launching {terminal_name} terminal...")
        start_mt5_terminal(terminal_path, login, password, server)
        
        print(f"‚è≥ Step 3: Waiting for {terminal_name} terminal to be ready...")
        if not wait_for_terminal_ready(terminal_path, login, password, server):
            print(f"‚ùå {terminal_name} terminal not ready")
            return False
        
        print(f"‚úÖ {terminal_name} terminal setup complete!")
        return True
        
    except Exception as e:
        print(f"‚ùå Error setting up {terminal_name} terminal: {e}")
        return False

def init_account(login, password, server, terminal_path):
    """Initialize MT5 account connection"""
    if not mt5.initialize(path=terminal_path, login=login, password=password, server=server):
        print(f"‚ùå Failed to initialize MT5 account {login}: {mt5.last_error()}")
        return False
    
    account_info = mt5.account_info()
    if account_info:
        print(f"‚úÖ Account {login} logged in successfully")
        return True
    else:
        print(f"‚ùå Account {login} connected but no account info")
        mt5.shutdown()
        return False

def get_master_positions():
    """Get all open positions from master account"""
    return mt5.positions_get()

def get_safe_tick_price(symbol, order_type):
    """Get tick price with fallback to symbol info if tick is not available"""
    tick = mt5.symbol_info_tick(symbol)
    if tick is None:
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info is None:
            print(f"‚ùå Cannot get price info for {symbol}")
            return None
        
        if order_type == 0:  # BUY
            return symbol_info.ask
        else:  # SELL
            return symbol_info.bid
    else:
        if order_type == 0:  # BUY
            return tick.ask
        else:  # SELL
            return tick.bid

def copy_position_to_slave(position):
    """Copy a position from master to slave account"""
    symbol = position.symbol
    volume = position.volume
    order_type = position.type
    
    price = get_safe_tick_price(symbol, order_type)
    if price is None:
        print(f"‚ùå Cannot get price for {symbol}, skipping trade")
        return False

    request = { 
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": volume,
        "type": order_type,
        "price": price,
        "deviation": 10,
        "magic": 123456,
        "comment": "Trade copied",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_FOK,
    }

    result = mt5.order_send(request)
    if result.retcode != mt5.TRADE_RETCODE_DONE:
        print(f"‚ùå Trade failed: retcode={result.retcode}, message: {result.comment}")
        return False
    else:
        print(f"‚úÖ Trade copied: {symbol}, {volume} lots, {'BUY' if order_type == 0 else 'SELL'}")
        return True

def positions_to_dict(positions):
    """Convert positions to a dictionary for comparison"""
    if positions is None:
        return {}
    return {(p.symbol, p.volume, p.type): p.ticket for p in positions}

def copy_trading_process(config):
    """Main copy trading process that runs continuously"""
    print("üéØ Starting copy trading process...")
    
    MASTER_LOGIN = config['MASTER_LOGIN']
    MASTER_PASSWORD = config['MASTER_PASSWORD']
    MASTER_SERVER = config['MASTER_SERVER']
    MASTER_PATH = config['MASTER_PATH']
    
    SLAVE_LOGIN = config['SLAVE_LOGIN']
    SLAVE_PASSWORD = config['SLAVE_PASSWORD']
    SLAVE_SERVER = config['SLAVE_SERVER']
    SLAVE_PATH = config['SLAVE_PATH']
    
    COPY_INTERVAL = config['COPY_INTERVAL']
    DISCORD_WEBHOOK_URL = config['DISCORD_WEBHOOK_URL']
    
    baseline_master_positions = {}
    baseline_initialized = False
    
    while True:
        try:
            # Connect to master terminal
            if init_account(MASTER_LOGIN, MASTER_PASSWORD, MASTER_SERVER, MASTER_PATH):
                master_positions = get_master_positions()
                master_snapshot = positions_to_dict(master_positions)
                mt5.shutdown()
            else:
                print("‚ùå Failed to connect to master, retrying...")
                time.sleep(COPY_INTERVAL)
                continue

            # Connect to slave terminal
            if init_account(SLAVE_LOGIN, SLAVE_PASSWORD, SLAVE_SERVER, SLAVE_PATH):
                slave_positions = get_master_positions()
                slave_snapshot = positions_to_dict(slave_positions)

                # Initialize baseline on first successful connection
                if not baseline_initialized:
                    print("üìä Initializing baseline - recording existing positions...")
                    baseline_master_positions = master_snapshot.copy()
                    baseline_initialized = True
                    print(f"üìä Baseline initialized with {len(baseline_master_positions)} existing positions")
                    
                    mt5.shutdown()
                    time.sleep(COPY_INTERVAL)
                    continue

                # Find new positions
                new_positions = {}
                for pos_key, master_ticket in master_snapshot.items():
                    if pos_key not in baseline_master_positions:
                        new_positions[pos_key] = master_ticket

                if new_positions:
                    print(f"üéØ Found {len(new_positions)} new positions to copy")
                    for p in master_positions:
                        pos_key = (p.symbol, p.volume, p.type)
                        if pos_key in new_positions:
                            print(f"üìà Copying new position: {p.symbol} {p.volume} lots ({'BUY' if p.type == 0 else 'SELL'})")
                            if copy_position_to_slave(p):
                                send_discord_notification(
                                    f"‚úÖ Trade copied: {p.symbol} {p.volume} lots ({'BUY' if p.type == 0 else 'SELL'})",
                                    DISCORD_WEBHOOK_URL
                                )

                # Update baseline
                baseline_master_positions.update(new_positions)
                
                mt5.shutdown()
            else:
                print("‚ùå Failed to connect to slave, retrying...")
                time.sleep(COPY_INTERVAL)
                continue

        except Exception as e:
            print(f"‚ùå Error in copy trading process: {e}")
            mt5.shutdown()
        
        time.sleep(COPY_INTERVAL)

if __name__ == "__main__":
    print("üöÄ Starting Dynamic MT5 Copy Trading...")
    
    # Get user ID from EC2 metadata or environment
    user_id = get_user_id_from_ec2()
    if user_id is None:
        print("‚ùå Could not determine user ID. Exiting.")
        sys.exit(1)
    
    print(f"üë§ Trading for user ID: {user_id}")
    
    # Load configuration from database
    config = load_configuration_from_database(user_id)
    
    if config is None:
        print("‚ùå No valid account configuration found in database.")
        print("‚è≥ Waiting for accounts to be added in dashboard...")
        
        # Wait for configuration in a loop
        while True:
            time.sleep(30)  # Check every 30 seconds
            print("üîÑ Checking database for account configuration...")
            config = load_configuration_from_database(user_id)
            if config is not None:
                print("‚úÖ Account configuration found in database!")
                break
    
    print(f"\n{'='*60}")
    print("üìã Current Configuration:")
    print(f"Master Account: {config['MASTER_LOGIN']}")
    print(f"Slave Account: {config['SLAVE_LOGIN']}")
    print(f"Copy Interval: {config['COPY_INTERVAL']} seconds")
    print(f"{'='*60}")
    
    # Send Discord notification
    send_discord_notification(
        f"üöÄ Dynamic Copy Trading started - Master: {config['MASTER_LOGIN']}, Slave: {config['SLAVE_LOGIN']}",
        config['DISCORD_WEBHOOK_URL']
    )
    
    # Setup terminals
    print(f"\nüöÄ Setting up terminals...")
    
    master_success = setup_single_terminal(
        config['MASTER_PATH'], 
        config['MASTER_LOGIN'], 
        config['MASTER_PASSWORD'], 
        config['MASTER_SERVER'], 
        "Master"
    )
    
    slave_success = setup_single_terminal(
        config['SLAVE_PATH'], 
        config['SLAVE_LOGIN'], 
        config['SLAVE_PASSWORD'], 
        config['SLAVE_SERVER'], 
        "Slave"
    )
    
    if master_success and slave_success:
        print(f"\nüéØ Both terminals ready! Starting copy trading...")
        send_discord_notification(
            f"‚úÖ Dynamic Copy Trading ready - Both terminals active!",
            config['DISCORD_WEBHOOK_URL']
        )
        
        try:
            copy_trading_process(config)
        except KeyboardInterrupt:
            send_discord_notification("‚èπÔ∏è Dynamic Copy Trading stopped by user", config['DISCORD_WEBHOOK_URL'])
            print("\nCopy trading stopped by user")
            mt5.shutdown()
        except Exception as e:
            send_discord_notification(f"‚ùå Dynamic Copy Trading error: {str(e)}", config['DISCORD_WEBHOOK_URL'])
            print(f"Error: {e}")
            mt5.shutdown()
    else:
        print("‚ùå Failed to setup terminals")
        send_discord_notification("‚ùå Failed to setup MT5 terminals", config['DISCORD_WEBHOOK_URL'])
